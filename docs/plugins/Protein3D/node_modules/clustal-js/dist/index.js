"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseClustalIter = parseClustalIter;
exports.parsePairwiseIter = parsePairwiseIter;
exports.parse = parse;
exports.parsePairwise = parsePairwise;
const pairwise_1 = require("./pairwise");
const util_1 = require("./util");
function parseClustalIter(arr) {
    const line = (0, util_1.getFirstNonEmptyLine)(arr);
    if (!line) {
        throw new Error('Empty file received');
    }
    const header = (0, util_1.parseHeader)(line);
    const res = (0, util_1.parseBlocks)(arr);
    if (res === undefined) {
        throw new Error('No blocks parsed');
    }
    const alns = res.seqs.map((n, index) => ({ id: res.ids[index], seq: n }));
    const { consensus } = res;
    if (consensus.length != alns[0].seq.length) {
        throw new Error(`Consensus length != sequence length. Con ${consensus.length} seq ${alns[0].seq.length}`);
    }
    return { consensus, alns, header };
}
function parsePairwiseIter(arr) {
    const res = (0, pairwise_1.parsePairwiseBlocks)(arr.split('\n')[Symbol.iterator]());
    if (res === undefined) {
        throw new Error('No blocks parsed');
    }
    const alns = res.seqs.map((n, index) => ({ id: res.ids[index], seq: n }));
    const { consensus } = res;
    if (consensus.length != alns[0].seq.length) {
        throw new Error(`Consensus length != sequence length. Con ${consensus.length} seq ${alns[0].seq.length}`);
    }
    if (alns.length !== 2) {
        throw new Error('More than two sequences in pairwise alignment');
    }
    return {
        consensus,
        alns: alns,
    };
}
function parse(contents) {
    const iter = contents.split('\n')[Symbol.iterator]();
    return parseClustalIter(iter);
}
function parsePairwise(contents) {
    return parsePairwiseIter(contents
        .split('\n')
        .filter(f => !f.startsWith('#'))
        .join('\n'));
}
//# sourceMappingURL=index.js.map