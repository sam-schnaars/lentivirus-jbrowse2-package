"use strict";
/**
 * Copyright (c) 2024 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MVSBuildPrimitiveShape = exports.MVSInlinePrimitiveData = exports.MVSDownloadPrimitiveData = exports.MVSPrimitiveShapes = exports.MVSPrimitivesData = void 0;
exports.getPrimitiveStructureRefs = getPrimitiveStructureRefs;
const lines_1 = require("../../../mol-geo/geometry/lines/lines");
const lines_builder_1 = require("../../../mol-geo/geometry/lines/lines-builder");
const cylinder_1 = require("../../../mol-geo/geometry/mesh/builder/cylinder");
const mesh_1 = require("../../../mol-geo/geometry/mesh/mesh");
const mesh_builder_1 = require("../../../mol-geo/geometry/mesh/mesh-builder");
const text_1 = require("../../../mol-geo/geometry/text/text");
const text_builder_1 = require("../../../mol-geo/geometry/text/text-builder");
const geometry_1 = require("../../../mol-math/geometry");
const linear_algebra_1 = require("../../../mol-math/linear-algebra");
const shape_1 = require("../../../mol-model/shape");
const structure_1 = require("../../../mol-model/structure");
const structure_query_1 = require("../../../mol-plugin-state/helpers/structure-query");
const objects_1 = require("../../../mol-plugin-state/objects");
const mol_state_1 = require("../../../mol-state");
const mol_task_1 = require("../../../mol-task");
const mol_util_1 = require("../../../mol-util");
const assets_1 = require("../../../mol-util/assets");
const color_1 = require("../../../mol-util/color");
const param_definition_1 = require("../../../mol-util/param-definition");
const string_1 = require("../../../mol-util/string");
const selections_1 = require("../helpers/selections");
const utils_1 = require("../helpers/utils");
const param_types_1 = require("../tree/mvs/param-types");
const annotation_structure_component_1 = require("./annotation-structure-component");
function getPrimitiveStructureRefs(primitives) {
    var _a, _b, _c, _d;
    const refs = new Set();
    for (const c of (_a = primitives.children) !== null && _a !== void 0 ? _a : []) {
        if (c.kind !== 'primitive')
            continue;
        const p = c.params;
        (_d = (_b = Builders[p.kind]) === null || _b === void 0 ? void 0 : (_c = _b[3]).refs) === null || _d === void 0 ? void 0 : _d.call(_c, p, refs);
    }
    return refs;
}
class MVSPrimitivesData extends objects_1.PluginStateObject.Create({ name: 'Primitive Data', typeClass: 'Object' }) {
}
exports.MVSPrimitivesData = MVSPrimitivesData;
class MVSPrimitiveShapes extends objects_1.PluginStateObject.Create({ name: 'Primitive Shapes', typeClass: 'Object' }) {
}
exports.MVSPrimitiveShapes = MVSPrimitiveShapes;
exports.MVSDownloadPrimitiveData = (0, annotation_structure_component_1.MVSTransform)({
    name: 'mvs-download-primitive-data',
    display: { name: 'MVS Primitives' },
    from: [objects_1.PluginStateObject.Root, objects_1.PluginStateObject.Molecule.Structure],
    to: MVSPrimitivesData,
    params: {
        uri: param_definition_1.ParamDefinition.Url('', { isHidden: true }),
        format: param_definition_1.ParamDefinition.Text('mvs-node-json', { isHidden: true })
    },
})({
    apply({ a, params, cache }, plugin) {
        return mol_task_1.Task.create('Download Primitive Data', async (ctx) => {
            const url = assets_1.Asset.getUrlAsset(plugin.managers.asset, params.uri);
            const asset = await plugin.managers.asset.resolve(url, 'string').runInContext(ctx);
            const node = JSON.parse(asset.data);
            cache.asset = asset;
            return new MVSPrimitivesData({
                node,
                defaultStructure: objects_1.PluginStateObject.Molecule.Structure.is(a) ? a.data : undefined,
                structureRefs: {},
                primitives: getPrimitives(node),
                options: { ...node.params },
                positionCache: new Map(),
                instances: getInstances(node.params),
            }, { label: 'Primitive Data' });
        });
    },
    dispose({ cache }) {
        var _a;
        (_a = cache === null || cache === void 0 ? void 0 : cache.asset) === null || _a === void 0 ? void 0 : _a.dispose();
    },
});
exports.MVSInlinePrimitiveData = (0, annotation_structure_component_1.MVSTransform)({
    name: 'mvs-inline-primitive-data',
    display: { name: 'MVS Primitives' },
    from: [objects_1.PluginStateObject.Root, objects_1.PluginStateObject.Molecule.Structure],
    to: MVSPrimitivesData,
    params: {
        node: param_definition_1.ParamDefinition.Value(undefined, { isHidden: true }),
    },
})({
    apply({ a, params }) {
        return new MVSPrimitivesData({
            node: params.node,
            defaultStructure: objects_1.PluginStateObject.Molecule.Structure.is(a) ? a.data : undefined,
            structureRefs: {},
            primitives: getPrimitives(params.node),
            options: { ...params.node.params },
            positionCache: new Map(),
            instances: getInstances(params.node.params),
        }, { label: 'Primitive Data' });
    }
});
exports.MVSBuildPrimitiveShape = (0, annotation_structure_component_1.MVSTransform)({
    name: 'mvs-build-primitive-shape',
    display: { name: 'MVS Primitives' },
    from: MVSPrimitivesData,
    to: objects_1.PluginStateObject.Shape.Provider,
    params: {
        kind: param_definition_1.ParamDefinition.Text('mesh')
    }
})({
    apply({ a, params, dependencies }) {
        var _a, _b, _c, _d, _e, _f;
        const structureRefs = dependencies ? (0, utils_1.collectMVSReferences)([objects_1.PluginStateObject.Molecule.Structure], dependencies) : {};
        const context = { ...a.data, structureRefs };
        const label = (0, string_1.capitalize)(params.kind);
        if (params.kind === 'mesh') {
            if (!hasPrimitiveKind(a.data, 'mesh'))
                return mol_state_1.StateObject.Null;
            return new objects_1.PluginStateObject.Shape.Provider({
                label,
                data: context,
                params: param_definition_1.ParamDefinition.withDefaults(mesh_1.Mesh.Params, { alpha: (_b = (_a = a.data.options) === null || _a === void 0 ? void 0 : _a.transparency) !== null && _b !== void 0 ? _b : 1 }),
                getShape: (_, data, __, prev) => buildPrimitiveMesh(data, prev === null || prev === void 0 ? void 0 : prev.geometry),
                geometryUtils: mesh_1.Mesh.Utils,
            }, { label });
        }
        else if (params.kind === 'labels') {
            if (!hasPrimitiveKind(a.data, 'label'))
                return mol_state_1.StateObject.Null;
            return new objects_1.PluginStateObject.Shape.Provider({
                label,
                data: context,
                params: param_definition_1.ParamDefinition.withDefaults(DefaultLabelParams, { alpha: (_d = (_c = a.data.options) === null || _c === void 0 ? void 0 : _c.label_transparency) !== null && _d !== void 0 ? _d : 1 }),
                getShape: (_, data, __, prev) => buildPrimitiveLabels(data, prev === null || prev === void 0 ? void 0 : prev.geometry),
                geometryUtils: text_1.Text.Utils,
            }, { label });
        }
        else if (params.kind === 'lines') {
            if (!hasPrimitiveKind(a.data, 'line'))
                return mol_state_1.StateObject.Null;
            return new objects_1.PluginStateObject.Shape.Provider({
                label,
                data: context,
                params: param_definition_1.ParamDefinition.withDefaults(lines_1.Lines.Params, { alpha: (_f = (_e = a.data.options) === null || _e === void 0 ? void 0 : _e.transparency) !== null && _f !== void 0 ? _f : 1 }),
                getShape: (_, data, __, prev) => buildPrimitiveLines(data, prev === null || prev === void 0 ? void 0 : prev.geometry),
                geometryUtils: lines_1.Lines.Utils,
            }, { label });
        }
        return mol_state_1.StateObject.Null;
    }
});
/* **************************************************** */
class GroupManager {
    constructor() {
        this.current = -1;
        this.groupToNodeMap = new Map();
        this.sizes = new Map();
        this.colors = new Map();
        this.tooltips = new Map();
    }
    allocateSingle(node) {
        const group = ++this.current;
        this.groupToNodeMap.set(group, node);
        return group;
    }
    allocateMany(node, groups) {
        const newGroups = new Map();
        const base = this.current;
        for (const g of groups) {
            if (newGroups.has(g))
                continue;
            const group = base + newGroups.size + 1;
            this.groupToNodeMap.set(group, node);
            newGroups.set(g, group);
        }
        this.current += newGroups.size + 1;
        return newGroups;
    }
    updateColor(group, color) {
        const c = (0, utils_1.decodeColor)(color);
        if (typeof c === 'number')
            this.colors.set(group, c);
    }
    updateTooltip(group, tooltip) {
        if (typeof tooltip === 'string')
            this.tooltips.set(group, tooltip);
    }
    updateSize(group, size) {
        if (typeof size === 'number')
            this.sizes.set(group, size);
    }
}
const BaseLabelProps = {
    ...param_definition_1.ParamDefinition.getDefaultValues(text_1.Text.Params),
    attachment: 'middle-center',
    fontQuality: 3,
    fontWeight: 'normal',
    borderWidth: 0.15,
    borderColor: (0, color_1.Color)(0x0),
    background: false,
    backgroundOpacity: 0.5,
    tether: false,
};
const DefaultLabelParams = param_definition_1.ParamDefinition.withDefaults(text_1.Text.Params, BaseLabelProps);
const Builders = {
    mesh: [addMesh, addMeshWireframe, noOp, {
            mesh: (m) => { var _a; return (_a = m.show_triangles) !== null && _a !== void 0 ? _a : true; },
            line: (m) => { var _a; return (_a = m.show_wireframe) !== null && _a !== void 0 ? _a : false; },
        }],
    lines: [addMesh, addLines, noOp, { line: true }],
    line: [addLineMesh, noOp, noOp, { mesh: true, refs: resolveLineRefs }],
    label: [noOp, noOp, addPrimitiveLabel, { label: true, refs: resolveLabelRefs }],
    distance_measurement: [addDistanceMesh, noOp, addDistanceLabel, { mesh: true, label: true, refs: resolveLineRefs }],
};
function getPrimitives(primitives) {
    var _a;
    return ((_a = primitives.children) !== null && _a !== void 0 ? _a : []).filter(c => c.kind === 'primitive');
}
function addRef(position, refs) {
    if ((0, param_types_1.isPrimitiveComponentExpressions)(position) && position.structure_ref) {
        refs.add(position.structure_ref);
    }
}
function hasPrimitiveKind(context, kind) {
    var _a, _b;
    for (const c of context.primitives) {
        const p = c.params;
        const test = (_b = (_a = Builders[p.kind]) === null || _a === void 0 ? void 0 : _a[3]) === null || _b === void 0 ? void 0 : _b[kind];
        if (typeof test === 'boolean') {
            if (test)
                return true;
        }
        else if (test === null || test === void 0 ? void 0 : test(p, context)) {
            return true;
        }
    }
    return false;
}
function resolveBasePosition(context, position, targetPosition) {
    return resolvePosition(context, position, targetPosition, undefined, undefined);
}
const _EmptySphere = geometry_1.Sphere3D.zero();
const _EmptyBox = geometry_1.Box3D.zero();
function resolvePosition(context, position, targetPosition, targetSphere, targetBox) {
    let expr;
    let pivotRef;
    if ((0, param_types_1.isVector3)(position)) {
        if (targetPosition)
            linear_algebra_1.Vec3.copy(targetPosition, position);
        if (targetSphere)
            geometry_1.Sphere3D.set(targetSphere, position, 0);
        if (targetBox)
            geometry_1.Box3D.set(targetBox, position, position);
        return;
    }
    if ((0, param_types_1.isPrimitiveComponentExpressions)(position)) {
        // TODO: take schema into account for possible optimization
        expr = (0, selections_1.rowsToExpression)(position.expressions);
        pivotRef = position.structure_ref;
    }
    else if ((0, param_types_1.isComponentExpression)(position)) {
        expr = (0, selections_1.rowToExpression)(position);
    }
    if (!expr) {
        console.error('Invalid expression', position);
        throw new Error('Invalid primitive potition expression, see console for details.');
    }
    const pivot = !pivotRef ? context.defaultStructure : context.structureRefs[pivotRef];
    if (!pivot) {
        throw new Error(`Structure with ref '${pivotRef !== null && pivotRef !== void 0 ? pivotRef : '<default>'}' not found.`);
    }
    const cackeKey = JSON.stringify(position);
    if (context.positionCache.has(cackeKey)) {
        const cached = context.positionCache.get(cackeKey);
        if (targetPosition)
            linear_algebra_1.Vec3.copy(targetPosition, cached[0].center);
        if (targetSphere)
            geometry_1.Sphere3D.copy(targetSphere, cached[0]);
        if (targetBox)
            geometry_1.Box3D.copy(targetBox, cached[1]);
        return;
    }
    const { selection } = structure_query_1.StructureQueryHelper.createAndRun(pivot, expr);
    let box;
    let sphere;
    if (structure_1.StructureSelection.isEmpty(selection)) {
        if (targetPosition)
            linear_algebra_1.Vec3.set(targetPosition, 0, 0, 0);
        box = _EmptyBox;
        sphere = _EmptySphere;
    }
    else {
        const loci = structure_1.StructureSelection.toLociWithSourceUnits(selection);
        const boundary = structure_1.StructureElement.Loci.getBoundary(loci);
        if (targetPosition)
            linear_algebra_1.Vec3.copy(targetPosition, boundary.sphere.center);
        box = boundary.box;
        sphere = boundary.sphere;
    }
    if (targetSphere)
        geometry_1.Sphere3D.copy(targetSphere, sphere);
    if (targetBox)
        geometry_1.Box3D.copy(targetBox, box);
    context.positionCache.set(cackeKey, [sphere, box]);
}
function getInstances(options) {
    var _a;
    if (!((_a = options === null || options === void 0 ? void 0 : options.instances) === null || _a === void 0 ? void 0 : _a.length))
        return undefined;
    return options.instances.map(i => linear_algebra_1.Mat4.fromArray((0, linear_algebra_1.Mat4)(), i, 0));
}
function buildPrimitiveMesh(context, prev) {
    var _a, _b, _c, _d;
    const meshBuilder = mesh_builder_1.MeshBuilder.createState(1024, 1024, prev);
    const state = { groups: new GroupManager(), mesh: meshBuilder };
    meshBuilder.currentGroup = -1;
    for (const c of context.primitives) {
        const p = c.params;
        const b = Builders[p.kind];
        if (!b) {
            console.warn(`Primitive ${p.kind} not supported`);
            continue;
        }
        b[0](context, state, c, p);
    }
    const { colors, tooltips } = state.groups;
    const tooltip = (_b = (_a = context.options) === null || _a === void 0 ? void 0 : _a.tooltip) !== null && _b !== void 0 ? _b : '';
    const color = (_d = (0, utils_1.decodeColor)((_c = context.options) === null || _c === void 0 ? void 0 : _c.color)) !== null && _d !== void 0 ? _d : 0x0;
    return shape_1.Shape.create('Mesh', {
        kind: 'mvs-primitives',
        node: context.node,
        groupToNode: state.groups.groupToNodeMap,
    }, mesh_builder_1.MeshBuilder.getMesh(meshBuilder), (g) => { var _a; return (_a = colors.get(g)) !== null && _a !== void 0 ? _a : color; }, (g) => 1, (g) => { var _a; return (_a = tooltips.get(g)) !== null && _a !== void 0 ? _a : tooltip; }, context.instances);
}
function buildPrimitiveLines(context, prev) {
    var _a, _b;
    const linesBuilder = lines_builder_1.LinesBuilder.create(1024, 1024, prev);
    const state = { groups: new GroupManager(), lines: linesBuilder };
    for (const c of context.primitives) {
        const p = c.params;
        const b = Builders[p.kind];
        if (!b) {
            console.warn(`Primitive ${p.kind} not supported`);
            continue;
        }
        b[1](context, state, c, p);
    }
    const color = (_b = (0, utils_1.decodeColor)((_a = context.options) === null || _a === void 0 ? void 0 : _a.color)) !== null && _b !== void 0 ? _b : 0x0;
    const { colors, sizes, tooltips } = state.groups;
    return shape_1.Shape.create('Lines', {
        kind: 'mvs-primitives',
        node: context.node,
        groupToNode: state.groups.groupToNodeMap,
    }, linesBuilder.getLines(), (g) => { var _a; return (_a = colors.get(g)) !== null && _a !== void 0 ? _a : color; }, (g) => { var _a; return (_a = sizes.get(g)) !== null && _a !== void 0 ? _a : 1; }, (g) => { var _a; return (_a = tooltips.get(g)) !== null && _a !== void 0 ? _a : ''; }, context.instances);
}
function buildPrimitiveLabels(context, prev) {
    var _a, _b;
    const labelsBuilder = text_builder_1.TextBuilder.create(BaseLabelProps, 1024, 1024, prev);
    const state = { groups: new GroupManager(), labels: labelsBuilder };
    for (const c of context.primitives) {
        const p = c.params;
        const b = Builders[p.kind];
        if (!b) {
            console.warn(`Primitive ${p.kind} not supported`);
            continue;
        }
        b[2](context, state, c, p);
    }
    const color = (_b = (0, utils_1.decodeColor)((_a = context.options) === null || _a === void 0 ? void 0 : _a.label_color)) !== null && _b !== void 0 ? _b : 0x0;
    const { colors, sizes, tooltips } = state.groups;
    return shape_1.Shape.create('Labels', {
        kind: 'mvs-primitives',
        node: context.node,
        groupToNode: state.groups.groupToNodeMap,
    }, labelsBuilder.getText(), (g) => { var _a; return (_a = colors.get(g)) !== null && _a !== void 0 ? _a : color; }, (g) => { var _a; return (_a = sizes.get(g)) !== null && _a !== void 0 ? _a : 1; }, (g) => { var _a; return (_a = tooltips.get(g)) !== null && _a !== void 0 ? _a : ''; }, context.instances);
}
function noOp() { }
function addMesh(context, { groups, mesh }, node, params) {
    var _a, _b;
    if (!params.show_triangles)
        return;
    const a = linear_algebra_1.Vec3.zero();
    const b = linear_algebra_1.Vec3.zero();
    const c = linear_algebra_1.Vec3.zero();
    const { indices, vertices, triangle_colors, triangle_groups, group_colors, group_tooltips } = params;
    const groupSet = (triangle_groups === null || triangle_groups === void 0 ? void 0 : triangle_groups.length) ? groups.allocateMany(node, triangle_groups) : undefined;
    for (let i = 0, _i = indices.length / 3; i < _i; i++) {
        if (groupSet) {
            const grp = triangle_groups[i];
            mesh.currentGroup = groupSet.get(grp);
            groups.updateColor(mesh.currentGroup, (_a = group_colors === null || group_colors === void 0 ? void 0 : group_colors[grp]) !== null && _a !== void 0 ? _a : params.color);
            groups.updateTooltip(mesh.currentGroup, group_tooltips === null || group_tooltips === void 0 ? void 0 : group_tooltips[grp]);
        }
        else {
            mesh.currentGroup = groups.allocateSingle(node);
            groups.updateColor(mesh.currentGroup, (_b = triangle_colors === null || triangle_colors === void 0 ? void 0 : triangle_colors[i]) !== null && _b !== void 0 ? _b : params.color);
            groups.updateTooltip(mesh.currentGroup, params.tooltip);
        }
        linear_algebra_1.Vec3.fromArray(a, vertices, 3 * indices[3 * i]);
        linear_algebra_1.Vec3.fromArray(b, vertices, 3 * indices[3 * i + 1]);
        linear_algebra_1.Vec3.fromArray(c, vertices, 3 * indices[3 * i + 2]);
        mesh_builder_1.MeshBuilder.addTriangle(mesh, a, b, c);
    }
}
function addMeshWireframe(context, { groups, lines }, node, params) {
    var _a, _b, _c;
    if (!params.show_wireframe)
        return;
    const a = linear_algebra_1.Vec3.zero();
    const b = linear_algebra_1.Vec3.zero();
    const c = linear_algebra_1.Vec3.zero();
    const { indices, vertices, triangle_colors, triangle_groups, group_colors, group_tooltips } = params;
    const groupSet = (triangle_groups === null || triangle_groups === void 0 ? void 0 : triangle_groups.length) ? groups.allocateMany(node, triangle_groups) : undefined;
    const radius = (_a = params.wireframe_radius) !== null && _a !== void 0 ? _a : 1;
    for (let i = 0, _i = indices.length / 3; i < _i; i++) {
        let group;
        if (groupSet) {
            const grp = triangle_groups[i];
            group = groupSet.get(grp);
            groups.updateColor(group, (_b = params.wireframe_color) !== null && _b !== void 0 ? _b : group_colors === null || group_colors === void 0 ? void 0 : group_colors[grp]);
            groups.updateTooltip(group, group_tooltips === null || group_tooltips === void 0 ? void 0 : group_tooltips[grp]);
        }
        else {
            group = groups.allocateSingle(node);
            groups.updateColor(group, (_c = params.wireframe_color) !== null && _c !== void 0 ? _c : triangle_colors === null || triangle_colors === void 0 ? void 0 : triangle_colors[i]);
            groups.updateTooltip(group, params.tooltip);
        }
        groups.updateSize(group, radius);
        linear_algebra_1.Vec3.fromArray(a, vertices, 3 * indices[3 * i]);
        linear_algebra_1.Vec3.fromArray(b, vertices, 3 * indices[3 * i + 1]);
        linear_algebra_1.Vec3.fromArray(c, vertices, 3 * indices[3 * i + 2]);
        lines.add(a[0], a[1], a[2], b[0], b[1], b[2], group);
        lines.add(b[0], b[1], b[2], c[0], c[1], c[2], group);
        lines.add(c[0], c[1], c[2], a[0], a[1], a[2], group);
    }
}
function addLines(context, { groups, lines }, node, params) {
    var _a, _b, _c, _d;
    const a = linear_algebra_1.Vec3.zero();
    const b = linear_algebra_1.Vec3.zero();
    const { indices, vertices, line_colors, line_groups, group_colors, group_tooltips, group_radius } = params;
    const groupSet = (line_groups === null || line_groups === void 0 ? void 0 : line_groups.length) ? groups.allocateMany(node, line_groups) : undefined;
    const radius = (_a = params.line_radius) !== null && _a !== void 0 ? _a : 1;
    for (let i = 0, _i = indices.length / 2; i < _i; i++) {
        let group;
        if (groupSet) {
            const grp = line_groups[i];
            group = groupSet.get(grp);
            groups.updateColor(group, (_b = group_colors === null || group_colors === void 0 ? void 0 : group_colors[grp]) !== null && _b !== void 0 ? _b : params.color);
            groups.updateTooltip(group, group_tooltips === null || group_tooltips === void 0 ? void 0 : group_tooltips[grp]);
            groups.updateSize(group, (_c = group_radius === null || group_radius === void 0 ? void 0 : group_radius[grp]) !== null && _c !== void 0 ? _c : radius);
        }
        else {
            group = groups.allocateSingle(node);
            groups.updateColor(group, (_d = line_colors === null || line_colors === void 0 ? void 0 : line_colors[i]) !== null && _d !== void 0 ? _d : params.color);
            groups.updateSize(group, radius);
            groups.updateTooltip(group, params.tooltip);
        }
        linear_algebra_1.Vec3.fromArray(a, vertices, 3 * indices[2 * i]);
        linear_algebra_1.Vec3.fromArray(b, vertices, 3 * indices[2 * i + 1]);
        lines.add(a[0], a[1], a[2], b[0], b[1], b[2], group);
    }
}
function resolveLineRefs(params, refs) {
    addRef(params.start, refs);
    addRef(params.end, refs);
}
const lStart = linear_algebra_1.Vec3.zero();
const lEnd = linear_algebra_1.Vec3.zero();
function addLineMesh(context, { groups, mesh }, node, params, options) {
    var _a;
    if (!(options === null || options === void 0 ? void 0 : options.skipResolvePosition)) {
        resolveBasePosition(context, params.start, lStart);
        resolveBasePosition(context, params.end, lEnd);
    }
    const radius = (_a = params.thickness) !== null && _a !== void 0 ? _a : 0.05;
    const cylinderProps = {
        radiusBottom: radius,
        radiusTop: radius,
        topCap: true,
        bottomCap: true,
    };
    mesh.currentGroup = groups.allocateSingle(node);
    groups.updateColor(mesh.currentGroup, params.color);
    groups.updateTooltip(mesh.currentGroup, params.tooltip);
    if (params.dash_length) {
        const dist = linear_algebra_1.Vec3.distance(lStart, lEnd);
        const count = Math.ceil(dist / (2 * params.dash_length));
        (0, cylinder_1.addFixedCountDashedCylinder)(mesh, lStart, lEnd, 1.0, count, true, cylinderProps);
    }
    else {
        (0, cylinder_1.addSimpleCylinder)(mesh, lStart, lEnd, cylinderProps);
    }
}
function getDistanceLabel(context, params) {
    resolveBasePosition(context, params.start, lStart);
    resolveBasePosition(context, params.end, lEnd);
    const dist = linear_algebra_1.Vec3.distance(lStart, lEnd);
    const distance = `${(0, mol_util_1.round)(dist, 2)} Å`;
    const label = typeof params.label_template === 'string' ? params.label_template.replace('{{distance}}', distance) : distance;
    return label;
}
function addDistanceMesh(context, state, node, params) {
    const tooltip = getDistanceLabel(context, params);
    addLineMesh(context, state, node, { ...params, tooltip }, { skipResolvePosition: true });
}
const labelPos = linear_algebra_1.Vec3.zero();
function addDistanceLabel(context, state, node, params) {
    var _a, _b, _c;
    const { labels, groups } = state;
    resolveBasePosition(context, params.start, lStart);
    resolveBasePosition(context, params.end, lEnd);
    const dist = linear_algebra_1.Vec3.distance(lStart, lEnd);
    const distance = `${(0, mol_util_1.round)(dist, 2)} Å`;
    const label = typeof params.label_template === 'string' ? params.label_template.replace('{{distance}}', distance) : distance;
    let size;
    if (params.label_size === 'auto') {
        size = Math.max(dist * ((_a = params.label_auto_size_scale) !== null && _a !== void 0 ? _a : 0.2), (_b = params.label_auto_size_min) !== null && _b !== void 0 ? _b : 0.01);
    }
    else if (typeof params.label_size === 'number') {
        size = params.label_size;
    }
    linear_algebra_1.Vec3.add(labelPos, lStart, lEnd);
    linear_algebra_1.Vec3.scale(labelPos, labelPos, 0.5);
    const group = groups.allocateSingle(node);
    groups.updateColor(group, params.label_color);
    groups.updateSize(group, size);
    labels.add(label, labelPos[0], labelPos[1], labelPos[2], 1.05 * ((_c = params.thickness) !== null && _c !== void 0 ? _c : 0.05), 1, group);
}
function resolveLabelRefs(params, refs) {
    addRef(params.position, refs);
}
function addPrimitiveLabel(context, state, node, params) {
    var _a;
    const { labels, groups } = state;
    resolveBasePosition(context, params.position, labelPos);
    const group = groups.allocateSingle(node);
    groups.updateColor(group, params.label_color);
    groups.updateSize(group, params.label_size);
    labels.add(params.text, labelPos[0], labelPos[1], labelPos[2], (_a = params.label_offset) !== null && _a !== void 0 ? _a : 0, 1, group);
}
