/**
 * Copyright (c) 2017-2024 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Gianluca Tomasello <giagitom@gmail.com>
 *
 * adapted from three.js (https://github.com/mrdoob/three.js/)
 * which under the MIT License, Copyright Â© 2010-2021 three.js authors
 */
export declare const apply_light_color = "\n#if defined(dIgnoreLight)\n    #ifdef bumpEnabled\n        if (uBumpFrequency > 0.0 && uBumpAmplitude > 0.0 && bumpiness > 0.0) {\n            material.rgb += fbm(vModelPosition * uBumpFrequency) * uBumpAmplitude * bumpiness;\n            material.rgb -= 0.5 * uBumpAmplitude * bumpiness;\n        }\n    #endif\n\n    #if defined(dRenderVariant_color)\n        material.rgb += material.rgb * emissive;\n    #endif\n\n    gl_FragColor = material;\n#else\n    #ifdef bumpEnabled\n        if (uBumpFrequency > 0.0 && uBumpAmplitude > 0.0 && bumpiness > 0.0) {\n            normal = perturbNormal(-vViewPosition, normal, fbm(vModelPosition * uBumpFrequency), (uBumpAmplitude * bumpiness) / uBumpFrequency);\n        }\n    #endif\n\n    vec4 color = material;\n\n    #if defined(dCelShaded)\n        // clamp to avoid artifacts\n        metalness = clamp(metalness, 0.0, 0.99);\n        roughness = clamp(roughness, 0.05, 1.0);\n    #endif\n\n    GeometricContext geometry;\n    geometry.position = -vViewPosition;\n    geometry.normal = normal;\n    geometry.viewDir = normalize(vViewPosition);\n\n    PhysicalMaterial physicalMaterial;\n    physicalMaterial.diffuseColor = color.rgb * (1.0 - metalness);\n    #ifdef enabledFragDepth\n        physicalMaterial.roughness = min(max(roughness, 0.0525), 1.0);\n    #else\n        vec3 dxy = max(abs(dFdx(normal)), abs(dFdy(normal)));\n        float geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\n        physicalMaterial.roughness = min(max(roughness, 0.0525) + geometryRoughness, 1.0);\n    #endif\n    physicalMaterial.specularColor = mix(vec3(0.04), color.rgb, metalness);\n    physicalMaterial.specularF90 = 1.0;\n\n    IncidentLight directLight;\n\n    vec3 outgoingLight = vec3(0.0);\n\n    #if defined(dCelShaded)\n        float celDiffuse;\n        float celSpecular;\n        float celIntensity;\n\n        #pragma unroll_loop_start\n        for (int i = 0; i < dLightCount; ++i) {\n            directLight.direction = uLightDirection[i];\n            directLight.color = uLightColor[i] * PI; // * PI for punctual light\n\n            celDiffuse = RECIPROCAL_PI * max(dot(geometry.normal, directLight.direction), 0.0) * (1.0 - metalness);\n            celSpecular = luminance(saturate(dot(geometry.normal, directLight.direction)) * BRDF_GGX(directLight.direction, geometry.viewDir, geometry.normal, physicalMaterial.specularColor, physicalMaterial.specularF90, roughness));\n\n            celIntensity = celDiffuse + celSpecular;\n            celIntensity = ceil(celIntensity * uCelSteps) / uCelSteps;\n\n            outgoingLight += color.rgb * directLight.color * celIntensity;\n        }\n        #pragma unroll_loop_end\n\n        outgoingLight += physicalMaterial.diffuseColor * luminance(uAmbientColor);\n    #else\n        ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n\n        #pragma unroll_loop_start\n        for (int i = 0; i < dLightCount; ++i) {\n            directLight.direction = uLightDirection[i];\n            directLight.color = uLightColor[i] * PI; // * PI for punctual light\n            RE_Direct_Physical(directLight, geometry, physicalMaterial, reflectedLight);\n        }\n        #pragma unroll_loop_end\n\n        vec3 irradiance = uAmbientColor * PI; // * PI for punctual light\n        RE_IndirectDiffuse_Physical(irradiance, geometry, physicalMaterial, reflectedLight);\n\n        // indirect specular only metals\n        vec3 radiance = uAmbientColor * metalness;\n        vec3 iblIrradiance = uAmbientColor * metalness;\n        vec3 clearcoatRadiance = vec3(0.0);\n        RE_IndirectSpecular_Physical(radiance, iblIrradiance, clearcoatRadiance, geometry, physicalMaterial, reflectedLight);\n\n        outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n    #endif\n    outgoingLight = clamp(outgoingLight, 0.01, 0.99); // prevents black artifacts on specular highlight with transparent background\n\n    #if defined(dRenderVariant_color)\n        outgoingLight += color.rgb * emissive;\n    #endif\n\n    gl_FragColor = vec4(outgoingLight, color.a);\n#endif\n\ngl_FragColor.rgb *= uExposure;\n";
