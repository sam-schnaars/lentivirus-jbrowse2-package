"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseLinearDisplay = void 0;
const react_1 = require("react");
const models_1 = require("@jbrowse/core/pluggableElementTypes/models");
const configuration_1 = require("@jbrowse/core/configuration");
const util_1 = require("@jbrowse/core/util");
const compositeMap_1 = __importDefault(require("@jbrowse/core/util/compositeMap"));
const tracks_1 = require("@jbrowse/core/util/tracks");
const mobx_1 = require("mobx");
const mobx_state_tree_1 = require("mobx-state-tree");
// icons
const MenuOpen_1 = __importDefault(require("@mui/icons-material/MenuOpen"));
const CenterFocusStrong_1 = __importDefault(require("@mui/icons-material/CenterFocusStrong"));
const serverSideRenderedBlock_1 = __importDefault(require("./serverSideRenderedBlock"));
const configSchema_1 = __importDefault(require("./configSchema"));
const TrackHeightMixin_1 = __importDefault(require("./TrackHeightMixin"));
const FeatureDensityMixin_1 = __importDefault(require("./FeatureDensityMixin"));
// lazies
const Tooltip = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('../components/Tooltip'))));
/**
 * #stateModel BaseLinearDisplay
 * #category display
 *
 * BaseLinearDisplay is used as the basis for many linear genome view tracks.
 * It is block based, and can use 'static blocks' or 'dynamic blocks'
 *
 * extends
 * - [BaseDisplay](../basedisplay)
 * - [TrackHeightMixin](../trackheightmixin)
 * - [FeatureDensityMixin](../featuredensitymixin)
 */
function stateModelFactory() {
    return mobx_state_tree_1.types
        .compose('BaseLinearDisplay', models_1.BaseDisplay, (0, TrackHeightMixin_1.default)(), (0, FeatureDensityMixin_1.default)(), mobx_state_tree_1.types.model({
        /**
         * #property
         * updated via autorun
         */
        blockState: mobx_state_tree_1.types.map(serverSideRenderedBlock_1.default),
        /**
         * #property
         */
        configuration: (0, configuration_1.ConfigurationReference)(configSchema_1.default),
    }))
        .volatile(() => ({
        featureIdUnderMouse: undefined,
        contextMenuFeature: undefined,
    }))
        .views(self => ({
        /**
         * #getter
         * if a display-level message should be displayed instead of the blocks,
         * make this return a react component
         */
        get DisplayMessageComponent() {
            return undefined;
        },
        /**
         * #getter
         */
        get blockType() {
            return 'staticBlocks';
        },
        /**
         * #getter
         */
        get blockDefinitions() {
            const view = (0, util_1.getContainingView)(self);
            if (!view.initialized) {
                throw new Error('view not initialized yet');
            }
            return view[this.blockType];
        },
    }))
        .views(self => ({
        /**
         * #getter
         * how many milliseconds to wait for the display to
         * "settle" before re-rendering a block
         */
        get renderDelay() {
            return 50;
        },
        /**
         * #getter
         */
        get TooltipComponent() {
            return Tooltip;
        },
        /**
         * #getter
         * returns a string feature ID if the globally-selected object
         * is probably a feature
         */
        get selectedFeatureId() {
            if ((0, mobx_state_tree_1.isAlive)(self)) {
                const { selection } = (0, util_1.getSession)(self);
                // does it quack like a feature?
                if ((0, util_1.isFeature)(selection)) {
                    return selection.id();
                }
            }
            return undefined;
        },
    }))
        .views(self => ({
        /**
         * #getter
         * a CompositeMap of `featureId -> feature obj` that
         * just looks in all the block data for that feature
         */
        get features() {
            const featureMaps = [];
            for (const block of self.blockState.values()) {
                if (block.features) {
                    featureMaps.push(block.features);
                }
            }
            return new compositeMap_1.default(featureMaps);
        },
        /**
         * #getter
         */
        get featureUnderMouse() {
            const feat = self.featureIdUnderMouse;
            return feat ? this.features.get(feat) : undefined;
        },
        /**
         * #getter
         */
        getFeatureOverlapping(blockKey, x, y) {
            var _a, _b;
            return (_b = (_a = self.blockState.get(blockKey)) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.getByCoord(x, y);
        },
        /**
         * #getter
         */
        getFeatureByID(blockKey, id) {
            var _a, _b;
            return (_b = (_a = self.blockState.get(blockKey)) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.getByID(id);
        },
        /**
         * #getter
         */
        searchFeatureByID(id) {
            let ret;
            self.blockState.forEach(block => {
                var _a;
                const val = (_a = block.layout) === null || _a === void 0 ? void 0 : _a.getByID(id);
                if (val) {
                    ret = val;
                }
            });
            return ret;
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        addBlock(key, block) {
            self.blockState.set(key, serverSideRenderedBlock_1.default.create({
                key,
                region: block.toRegion(),
            }));
        },
        /**
         * #action
         */
        deleteBlock(key) {
            self.blockState.delete(key);
        },
        /**
         * #action
         */
        selectFeature(feature) {
            const session = (0, util_1.getSession)(self);
            if ((0, util_1.isSessionModelWithWidgets)(session)) {
                const featureWidget = session.addWidget('BaseFeatureWidget', 'baseFeature', {
                    view: (0, util_1.getContainingView)(self),
                    track: (0, util_1.getContainingTrack)(self),
                    featureData: feature.toJSON(),
                });
                session.showWidget(featureWidget);
            }
            if ((0, util_1.isSelectionContainer)(session)) {
                session.setSelection(feature);
            }
        },
        /**
         * #action
         */
        navToFeature(feature) {
            const view = (0, util_1.getContainingView)(self);
            view.navTo({
                refName: feature.get('refName'),
                start: feature.get('start'),
                end: feature.get('end'),
            });
        },
        /**
         * #action
         */
        clearFeatureSelection() {
            (0, util_1.getSession)(self).clearSelection();
        },
        /**
         * #action
         */
        setFeatureIdUnderMouse(feature) {
            self.featureIdUnderMouse = feature;
        },
        /**
         * #action
         */
        setContextMenuFeature(feature) {
            self.contextMenuFeature = feature;
        },
    }))
        .actions(self => {
        const { reload: superReload } = self;
        return {
            /**
             * #action
             */
            async reload() {
                self.setError();
                self.setCurrStatsBpPerPx(0);
                self.clearFeatureDensityStats();
                [...self.blockState.values()].forEach(val => {
                    val.doReload();
                });
                superReload();
            },
        };
    })
        .views(self => ({
        /**
         * #method
         */
        trackMenuItems() {
            return [];
        },
        /**
         * #method
         */
        contextMenuItems() {
            return [
                ...(self.contextMenuFeature
                    ? [
                        {
                            label: 'Open feature details',
                            icon: MenuOpen_1.default,
                            onClick: () => {
                                if (self.contextMenuFeature) {
                                    self.selectFeature(self.contextMenuFeature);
                                }
                            },
                        },
                        {
                            label: 'Zoom to feature',
                            icon: CenterFocusStrong_1.default,
                            onClick: () => {
                                if (self.contextMenuFeature) {
                                    self.navToFeature(self.contextMenuFeature);
                                }
                            },
                        },
                    ]
                    : []),
            ];
        },
        /**
         * #method
         */
        renderProps() {
            return {
                ...(0, tracks_1.getParentRenderProps)(self),
                notReady: !self.featureDensityStatsReady,
                rpcDriverName: self.rpcDriverName,
                displayModel: self,
                onFeatureClick(_, featureId) {
                    const f = featureId || self.featureIdUnderMouse;
                    if (!f) {
                        self.clearFeatureSelection();
                    }
                    else {
                        const feature = self.features.get(f);
                        if (feature) {
                            self.selectFeature(feature);
                        }
                    }
                },
                onClick() {
                    self.clearFeatureSelection();
                },
                // similar to click but opens a menu with further options
                onFeatureContextMenu(_, featureId) {
                    const f = featureId || self.featureIdUnderMouse;
                    if (!f) {
                        self.clearFeatureSelection();
                    }
                    else {
                        // feature id under mouse passed to context menu
                        self.setContextMenuFeature(self.features.get(f));
                    }
                },
                onMouseMove(_, featureId) {
                    self.setFeatureIdUnderMouse(featureId);
                },
                onMouseLeave(_) {
                    self.setFeatureIdUnderMouse(undefined);
                },
                onContextMenu() {
                    self.setContextMenuFeature(undefined);
                    self.clearFeatureSelection();
                },
            };
        },
    }))
        .actions(self => ({
        /**
         * #method
         */
        async renderSvg(opts) {
            const { renderBaseLinearDisplaySvg } = await Promise.resolve().then(() => __importStar(require('./renderSvg')));
            return renderBaseLinearDisplaySvg(self, opts);
        },
        afterAttach() {
            // watch the parent's blocks to update our block state when they change,
            // then we recreate the blocks on our own model (creating and deleting to
            // match the parent blocks)
            (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.autorun)(() => {
                const blocksPresent = {};
                const view = (0, util_1.getContainingView)(self);
                if (!view.initialized) {
                    return;
                }
                self.blockDefinitions.contentBlocks.forEach(block => {
                    blocksPresent[block.key] = true;
                    if (!self.blockState.has(block.key)) {
                        self.addBlock(block.key, block);
                    }
                });
                self.blockState.forEach((_, key) => {
                    if (!blocksPresent[key]) {
                        self.deleteBlock(key);
                    }
                });
            }));
        },
    }))
        .preProcessSnapshot(snap => {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!snap) {
            return snap;
        }
        // rewrite "height" from older snapshots to "heightPreConfig", this allows
        // us to maintain a height "getter" going forward
        // @ts-expect-error
        const { height, ...rest } = snap;
        return { heightPreConfig: height, ...rest };
    })
        .postProcessSnapshot(snap => {
        // xref https://github.com/mobxjs/mobx-state-tree/issues/1524 for Omit
        const r = snap;
        const { blockState, ...rest } = r;
        return rest;
    });
}
exports.BaseLinearDisplay = stateModelFactory();
