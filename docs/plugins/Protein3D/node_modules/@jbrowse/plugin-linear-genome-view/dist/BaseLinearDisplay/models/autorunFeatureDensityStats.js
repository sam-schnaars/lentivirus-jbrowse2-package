"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = autorunFeatureDensityStats;
const util_1 = require("@jbrowse/core/util");
const mobx_state_tree_1 = require("mobx-state-tree");
// stats estimation autorun calls getFeatureDensityStats against the data
// adapter which by default uses featureDensity, but can also respond with a
// byte size estimate and fetch size limit (data adapter can define what is too
// much data)
async function autorunFeatureDensityStats(self) {
    var _a;
    try {
        const view = (0, util_1.getContainingView)(self);
        // extra check for contentBlocks.length
        // https://github.com/GMOD/jbrowse-components/issues/2694
        if (!view.initialized ||
            !view.staticBlocks.contentBlocks.length ||
            view.bpPerPx === self.currStatsBpPerPx ||
            self.error) {
            return;
        }
        // don't re-estimate featureDensity even if zoom level changes,
        // jbrowse1-style assume it's sort of representative
        if (((_a = self.featureDensityStats) === null || _a === void 0 ? void 0 : _a.featureDensity) !== undefined) {
            self.setCurrStatsBpPerPx(view.bpPerPx);
            return;
        }
        self.clearFeatureDensityStats();
        self.setCurrStatsBpPerPx(view.bpPerPx);
        const stats = await self.getFeatureDensityStats();
        if ((0, mobx_state_tree_1.isAlive)(self)) {
            self.setFeatureDensityStats(stats);
        }
    }
    catch (e) {
        if (!(0, util_1.isAbortException)(e) && (0, mobx_state_tree_1.isAlive)(self)) {
            console.error(e);
            self.setError(e);
        }
    }
}
