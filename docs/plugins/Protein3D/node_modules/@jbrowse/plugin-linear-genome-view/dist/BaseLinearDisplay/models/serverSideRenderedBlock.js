"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderBlockData = renderBlockData;
const mobx_state_tree_1 = require("mobx-state-tree");
const configuration_1 = require("@jbrowse/core/configuration");
const util_1 = require("@jbrowse/core/util");
const mst_1 = require("@jbrowse/core/util/types/mst");
const types_1 = require("@jbrowse/core/util/types");
const tracks_1 = require("@jbrowse/core/util/tracks");
// locals
const ServerSideRenderedBlockContent_1 = __importDefault(require("../components/ServerSideRenderedBlockContent"));
// the MST state of a single server-side-rendered block in a display
const blockState = mobx_state_tree_1.types
    .model('BlockState', {
    key: mobx_state_tree_1.types.string,
    region: mst_1.Region,
    reloadFlag: 0,
    isLeftEndOfDisplayedRegion: false,
    isRightEndOfDisplayedRegion: false,
})
    // NOTE: all this volatile stuff has to be filled in at once, so that it stays consistent
    .volatile(() => ({
    renderInProgress: undefined,
    filled: false,
    reactElement: undefined,
    features: undefined,
    layout: undefined,
    status: '',
    error: undefined,
    message: undefined,
    maxHeightReached: false,
    ReactComponent: ServerSideRenderedBlockContent_1.default,
    renderProps: undefined,
}))
    .actions(self => {
    let renderInProgress;
    return {
        doReload() {
            self.reloadFlag = self.reloadFlag + 1;
        },
        afterAttach() {
            const display = (0, util_1.getContainingDisplay)(self);
            setTimeout(() => {
                if ((0, mobx_state_tree_1.isAlive)(self)) {
                    (0, util_1.makeAbortableReaction)(self, renderBlockData, renderBlockEffect, // reaction doesn't expect async here
                    {
                        name: `${display.id}/${(0, util_1.assembleLocString)(self.region)} rendering`,
                        delay: display.renderDelay,
                        fireImmediately: true,
                    }, this.setLoading, this.setRendered, this.setError);
                }
            }, display.renderDelay);
        },
        setStatus(message) {
            self.status = message;
        },
        setLoading(abortController) {
            if (renderInProgress !== undefined &&
                !renderInProgress.signal.aborted) {
                renderInProgress.abort();
            }
            self.filled = false;
            self.message = undefined;
            self.reactElement = undefined;
            self.features = undefined;
            self.layout = undefined;
            self.error = undefined;
            self.maxHeightReached = false;
            self.renderProps = undefined;
            renderInProgress = abortController;
        },
        setMessage(messageText) {
            if (renderInProgress && !renderInProgress.signal.aborted) {
                renderInProgress.abort();
            }
            self.filled = false;
            self.message = messageText;
            self.reactElement = undefined;
            self.features = undefined;
            self.layout = undefined;
            self.error = undefined;
            self.maxHeightReached = false;
            self.renderProps = undefined;
            renderInProgress = undefined;
        },
        setRendered(props) {
            if (!props) {
                return;
            }
            const { reactElement, features, layout, maxHeightReached, renderProps, } = props;
            self.filled = true;
            self.message = undefined;
            self.reactElement = reactElement;
            self.features = features;
            self.layout = layout;
            self.error = undefined;
            self.maxHeightReached = maxHeightReached;
            self.renderProps = renderProps;
            renderInProgress = undefined;
        },
        setError(error) {
            console.error(error);
            if (renderInProgress && !renderInProgress.signal.aborted) {
                renderInProgress.abort();
            }
            // the rendering failed for some reason
            self.filled = false;
            self.message = undefined;
            self.reactElement = undefined;
            self.features = undefined;
            self.layout = undefined;
            self.maxHeightReached = false;
            self.error = error;
            self.renderProps = undefined;
            renderInProgress = undefined;
            if ((0, types_1.isRetryException)(error)) {
                this.reload();
            }
        },
        reload() {
            self.renderInProgress = undefined;
            self.filled = false;
            self.reactElement = undefined;
            self.features = undefined;
            self.layout = undefined;
            self.error = undefined;
            self.message = undefined;
            self.maxHeightReached = false;
            self.ReactComponent = ServerSideRenderedBlockContent_1.default;
            self.renderProps = undefined;
            (0, mobx_state_tree_1.getParent)(self, 2).reload();
        },
        beforeDestroy() {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            ;
            (async () => {
                try {
                    if (renderInProgress && !renderInProgress.signal.aborted) {
                        renderInProgress.abort();
                    }
                    const display = (0, util_1.getContainingDisplay)(self);
                    const { rpcManager } = (0, util_1.getSession)(self);
                    const { rendererType } = display;
                    const { renderArgs } = renderBlockData((0, mobx_state_tree_1.cast)(self));
                    // renderArgs can be undefined if an error occurred in this block
                    if (renderArgs) {
                        await rendererType.freeResourcesInClient(rpcManager, JSON.parse(JSON.stringify(renderArgs)));
                    }
                }
                catch (e) {
                    console.error('Error while destroying block', e);
                }
            })();
        },
    };
});
exports.default = blockState;
// calls the render worker to render the block content not using a flow for
// this, because the flow doesn't work with autorun
function renderBlockData(self, optDisplay) {
    try {
        const display = optDisplay || (0, util_1.getContainingDisplay)(self);
        const { assemblyManager, rpcManager } = (0, util_1.getSession)(display);
        const { adapterConfig, rendererType, error, parentTrack } = display;
        const assemblyNames = (0, tracks_1.getTrackAssemblyNames)(parentTrack);
        const regionAsm = self.region.assemblyName;
        if (!assemblyNames.includes(regionAsm) &&
            !assemblyNames.some(name => { var _a; return (_a = assemblyManager.get(name)) === null || _a === void 0 ? void 0 : _a.hasName(regionAsm); })) {
            throw new Error(`region assembly (${regionAsm}) does not match track assemblies (${assemblyNames})`);
        }
        const renderProps = display.renderProps();
        const { config } = renderProps;
        // This line is to trigger the mobx reaction when the config changes
        // It won't trigger the reaction if it doesn't think we're accessing it
        (0, configuration_1.readConfObject)(config);
        const sessionId = (0, tracks_1.getRpcSessionId)(display);
        const layoutId = (0, util_1.getContainingView)(display).id;
        const cannotBeRenderedReason = display.regionCannotBeRendered(self.region);
        return {
            rendererType,
            rpcManager,
            renderProps,
            cannotBeRenderedReason,
            displayError: error,
            renderArgs: {
                statusCallback: (message) => {
                    if ((0, mobx_state_tree_1.isAlive)(self)) {
                        self.setStatus(message);
                    }
                },
                assemblyName: self.region.assemblyName,
                regions: [(0, mobx_state_tree_1.getSnapshot)(self.region)],
                adapterConfig,
                rendererType: rendererType.name,
                sessionId,
                layoutId,
                blockKey: self.key,
                reloadFlag: self.reloadFlag,
                timeout: 1000000, // 10000,
            },
        };
    }
    catch (e) {
        return { displayError: e };
    }
}
async function renderBlockEffect(props, signal, self) {
    if (!props) {
        return;
    }
    const { rendererType, renderProps, rpcManager, renderArgs, cannotBeRenderedReason, displayError, } = props;
    if (!(0, mobx_state_tree_1.isAlive)(self)) {
        return undefined;
    }
    if (displayError) {
        self.setError(displayError);
        return undefined;
    }
    if (cannotBeRenderedReason) {
        self.setMessage(cannotBeRenderedReason);
        return undefined;
    }
    if (renderProps.notReady) {
        return undefined;
    }
    const { reactElement, features, layout, maxHeightReached } = await rendererType.renderInClient(rpcManager, {
        ...renderArgs,
        ...renderProps,
        viewParams: (0, util_1.getViewParams)(self),
        signal,
    });
    return {
        reactElement,
        features,
        layout,
        maxHeightReached,
        renderProps,
    };
}
