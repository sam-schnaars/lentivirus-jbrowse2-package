"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = FeatureDensityMixin;
const react_1 = __importDefault(require("react"));
const configuration_1 = require("@jbrowse/core/configuration");
const util_1 = require("@jbrowse/core/util");
const mobx_1 = require("mobx");
const mobx_state_tree_1 = require("mobx-state-tree");
const TooLargeMessage_1 = __importDefault(require("../components/TooLargeMessage"));
const util_2 = require("./util");
const autorunFeatureDensityStats_1 = __importDefault(require("./autorunFeatureDensityStats"));
/**
 * #stateModel FeatureDensityMixin
 * #category display
 */
function FeatureDensityMixin() {
    return mobx_state_tree_1.types
        .model({
        /**
         * #property
         */
        userBpPerPxLimit: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.number),
        /**
         * #property
         */
        userByteSizeLimit: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.number),
    })
        .volatile(() => ({
        featureDensityStatsP: undefined,
        featureDensityStats: undefined,
        currStatsBpPerPx: 0,
    }))
        .views(self => ({
        /**
         * #getter
         */
        get currentBytesRequested() {
            var _a;
            return ((_a = self.featureDensityStats) === null || _a === void 0 ? void 0 : _a.bytes) || 0;
        },
        /**
         * #getter
         */
        get currentFeatureScreenDensity() {
            var _a;
            const view = (0, util_1.getContainingView)(self);
            return (((_a = self.featureDensityStats) === null || _a === void 0 ? void 0 : _a.featureDensity) || 0) * view.bpPerPx;
        },
        /**
         * #getter
         */
        get maxFeatureScreenDensity() {
            // @ts-expect-error
            return (0, configuration_1.getConf)(self, 'maxFeatureScreenDensity');
        },
        /**
         * #getter
         */
        get featureDensityStatsReady() {
            const view = (0, util_1.getContainingView)(self);
            return (self.currStatsBpPerPx === view.bpPerPx &&
                (!!self.featureDensityStats || !!self.userBpPerPxLimit));
        },
        /**
         * #getter
         */
        get maxAllowableBytes() {
            var _a;
            return (self.userByteSizeLimit ||
                ((_a = self.featureDensityStats) === null || _a === void 0 ? void 0 : _a.fetchSizeLimit) ||
                // @ts-expect-error
                (0, configuration_1.getConf)(self, 'fetchSizeLimit'));
        },
    }))
        .actions(self => ({
        afterAttach() {
            (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.autorun)(() => (0, autorunFeatureDensityStats_1.default)(self)));
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        setCurrStatsBpPerPx(n) {
            self.currStatsBpPerPx = n;
        },
        /**
         * #action
         */
        setFeatureDensityStatsLimit(stats) {
            const view = (0, util_1.getContainingView)(self);
            if (stats === null || stats === void 0 ? void 0 : stats.bytes) {
                self.userByteSizeLimit = stats.bytes;
            }
            else {
                self.userBpPerPxLimit = view.bpPerPx;
            }
        },
        /**
         * #action
         */
        getFeatureDensityStats() {
            if (!self.featureDensityStatsP) {
                self.featureDensityStatsP = (0, util_2.getFeatureDensityStatsPre)(self).catch((e) => {
                    if ((0, mobx_state_tree_1.isAlive)(self)) {
                        this.setFeatureDensityStatsP(undefined);
                    }
                    throw e;
                });
            }
            return self.featureDensityStatsP;
        },
        /**
         * #action
         */
        setFeatureDensityStatsP(arg) {
            self.featureDensityStatsP = arg;
        },
        /**
         * #action
         */
        setFeatureDensityStats(featureDensityStats) {
            self.featureDensityStats = featureDensityStats;
        },
        /**
         * #action
         */
        clearFeatureDensityStats() {
            self.featureDensityStatsP = undefined;
            self.featureDensityStats = undefined;
        },
    }))
        .views(self => ({
        /**
         * #getter
         * region is too large if:
         * - stats are ready
         * - region is greater than 20kb (don't warn when zoomed in less than that)
         * - and bytes is greater than max allowed bytes or density greater than max
         *   density
         */
        get regionTooLarge() {
            const view = (0, util_1.getContainingView)(self);
            if (!self.featureDensityStatsReady ||
                view.dynamicBlocks.totalBp < 20000) {
                return false;
            }
            return (self.currentBytesRequested > self.maxAllowableBytes ||
                (self.userBpPerPxLimit
                    ? view.bpPerPx > self.userBpPerPxLimit
                    : self.currentFeatureScreenDensity > self.maxFeatureScreenDensity));
        },
        /**
         * #getter
         * only shows a message of bytes requested is defined, the feature density
         * based stats don't produce any helpful message besides to zoom in
         */
        get regionTooLargeReason() {
            const req = self.currentBytesRequested;
            const max = self.maxAllowableBytes;
            return req && req > max
                ? `Requested too much data (${(0, util_2.getDisplayStr)(req)})`
                : '';
        },
    }))
        .views(self => ({
        /**
         * #method
         */
        regionCannotBeRenderedText(_region) {
            return self.regionTooLarge ? 'Force load to see features' : '';
        },
        /**
         * #method
         * @param region -
         * @returns falsy if the region is fine to try rendering. Otherwise,
         *  return a react node + string of text.
         *  string of text describes why it cannot be rendered
         *  react node allows user to force load at current setting
         */
        regionCannotBeRendered(_region) {
            return self.regionTooLarge ? (react_1.default.createElement(TooLargeMessage_1.default, { model: self })) : null;
        },
    }));
}
