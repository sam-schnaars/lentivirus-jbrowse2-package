"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const mobx_react_1 = require("mobx-react");
const material_1 = require("@mui/material");
const mui_1 = require("tss-react/mui");
const util_1 = require("@jbrowse/core/util");
// locals
const RefNameAutocomplete_1 = __importDefault(require("./RefNameAutocomplete"));
const util_2 = require("./util");
const searchUtils_1 = require("../../searchUtils");
const consts_1 = require("../consts");
const useStyles = (0, mui_1.makeStyles)()(() => ({
    headerRefName: {
        minWidth: 100,
    },
}));
const SearchBox = (0, mobx_react_1.observer)(function ({ model, showHelp, }) {
    const { classes } = useStyles();
    const theme = (0, material_1.useTheme)();
    const session = (0, util_1.getSession)(model);
    const { textSearchManager, assemblyManager } = session;
    const { assemblyNames, rankSearchResults } = model;
    const assemblyName = assemblyNames[0];
    const assembly = assemblyManager.get(assemblyName);
    const searchScope = model.searchScope(assemblyName);
    return (react_1.default.createElement(RefNameAutocomplete_1.default, { showHelp: showHelp, onSelect: async (option) => {
            var _a;
            try {
                if (option.hasLocation()) {
                    await (0, searchUtils_1.navToOption)({ option, model, assemblyName });
                }
                else if ((_a = option.results) === null || _a === void 0 ? void 0 : _a.length) {
                    model.setSearchResults(option.results, option.getLabel());
                }
                else if (assembly) {
                    await (0, searchUtils_1.handleSelectedRegion)({
                        input: option.getLabel(),
                        assembly,
                        model,
                    });
                }
            }
            catch (e) {
                console.error(e);
                (0, util_1.getSession)(model).notify(`${e}`, 'warning');
            }
        }, assemblyName: assemblyName, fetchResults: queryString => (0, util_2.fetchResults)({
            queryString,
            searchScope,
            rankSearchResults,
            textSearchManager,
            assembly,
        }), model: model, minWidth: 175, TextFieldProps: {
            variant: 'outlined',
            className: classes.headerRefName,
            style: {
                margin: consts_1.SPACING,
            },
            InputProps: {
                style: {
                    padding: 0,
                    height: consts_1.WIDGET_HEIGHT,
                    background: (0, material_1.alpha)(theme.palette.background.paper, 0.8),
                },
            },
        } }));
});
exports.default = SearchBox;
