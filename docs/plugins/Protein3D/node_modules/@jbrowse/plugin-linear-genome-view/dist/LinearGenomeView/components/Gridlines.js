"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const mui_1 = require("tss-react/mui");
const mobx_react_1 = require("mobx-react");
const Block_1 = require("../../BaseLinearDisplay/components/Block");
const util_1 = require("../util");
const useStyles = (0, mui_1.makeStyles)()(theme => ({
    verticalGuidesZoomContainer: {
        position: 'absolute',
        height: '100%',
        width: '100%',
        zIndex: 1,
        pointerEvents: 'none',
    },
    verticalGuidesContainer: {
        position: 'absolute',
        height: '100%',
        zIndex: 1,
        pointerEvents: 'none',
        display: 'flex',
    },
    tick: {
        position: 'absolute',
        height: '100%',
        width: 1,
    },
    majorTick: {
        background: theme.palette.action.disabled,
    },
    minorTick: {
        background: theme.palette.divider,
    },
}));
function RenderedBlockLines({ block, bpPerPx, }) {
    const { classes, cx } = useStyles();
    const ticks = (0, util_1.makeTicks)(block.start, block.end, bpPerPx);
    return (react_1.default.createElement(Block_1.ContentBlock, { block: block }, ticks.map(({ type, base }) => {
        const x = (block.reversed ? block.end - base : base - block.start) / bpPerPx;
        return (react_1.default.createElement("div", { key: base, className: cx(classes.tick, type === 'major' || type === 'labeledMajor'
                ? classes.majorTick
                : classes.minorTick), style: { left: x } }));
    })));
}
const RenderedVerticalGuides = (0, mobx_react_1.observer)(({ model }) => {
    const { staticBlocks, bpPerPx } = model;
    return (react_1.default.createElement(react_1.default.Fragment, null, staticBlocks.map((block, index) => {
        const k = `${block.key}-${index}`;
        if (block.type === 'ContentBlock') {
            return react_1.default.createElement(RenderedBlockLines, { key: k, block: block, bpPerPx: bpPerPx });
        }
        else if (block.type === 'ElidedBlock') {
            return react_1.default.createElement(Block_1.ElidedBlock, { key: k, width: block.widthPx });
        }
        else if (block.type === 'InterRegionPaddingBlock') {
            return (react_1.default.createElement(Block_1.InterRegionPaddingBlock, { key: k, width: block.widthPx, boundary: block.variant === 'boundary' }));
        }
        return null;
    })));
});
const Gridlines = (0, mobx_react_1.observer)(function ({ model }) {
    const { classes } = useStyles();
    // find the block that needs pinning to the left side for context
    const offsetLeft = model.staticBlocks.offsetPx - model.offsetPx;
    return (react_1.default.createElement("div", { className: classes.verticalGuidesZoomContainer, style: {
            transform: model.scaleFactor !== 1 ? `scaleX(${model.scaleFactor})` : undefined,
        } },
        react_1.default.createElement("div", { className: classes.verticalGuidesContainer, style: {
                left: offsetLeft,
                width: model.staticBlocks.totalWidthPx,
            } },
            react_1.default.createElement(RenderedVerticalGuides, { model: model }))));
});
exports.default = Gridlines;
