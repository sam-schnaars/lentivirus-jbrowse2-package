"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFiltered = getFiltered;
exports.aggregateResults = aggregateResults;
exports.getDeduplicatedResult = getDeduplicatedResult;
const BaseResults_1 = __importDefault(require("@jbrowse/core/TextSearch/BaseResults"));
// filter so don't need re-filtering
function filterOptions(options, searchQuery) {
    return options.filter(({ result }) => result.getLabel().toLowerCase().includes(searchQuery) ||
        result.matchedObject);
}
// the logic of this method is to only apply a filter to RefSequenceResults
// because they do not have a matchedObject. the trix search results already
function getFiltered(opts, inputValue) {
    const filtered = filterOptions(opts, inputValue.toLocaleLowerCase());
    return [
        ...filtered.slice(0, 100),
        ...(filtered.length > 100
            ? [
                {
                    group: 'limitOption',
                    result: new BaseResults_1.default({
                        label: 'keep typing for more results',
                    }),
                },
            ]
            : []),
    ];
}
function aggregateResults(results) {
    const m = {};
    for (const result of results) {
        const displayString = result.getDisplayString();
        if (!m[displayString]) {
            m[displayString] = [];
        }
        m[displayString].push(result);
    }
    return m;
}
function getDeduplicatedResult(results) {
    return Object.entries(aggregateResults(results)).map(([displayString, results]) => results.length === 1
        ? {
            result: results[0],
        }
        : {
            // deduplicate a "multi-result"
            result: new BaseResults_1.default({
                displayString,
                results,
                label: displayString,
            }),
        });
}
