"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderToSvg = exports.ZoomControls = exports.SearchBox = exports.RefNameAutocomplete = exports.LinearGenomeView = exports.ReactComponent = void 0;
exports.stateModelFactory = stateModelFactory;
const react_1 = require("react");
const configuration_1 = require("@jbrowse/core/configuration");
const models_1 = require("@jbrowse/core/pluggableElementTypes/models");
const mst_1 = require("@jbrowse/core/util/types/mst");
const util_1 = require("@jbrowse/core/util");
const calculateDynamicBlocks_1 = __importDefault(require("@jbrowse/core/util/calculateDynamicBlocks"));
const calculateStaticBlocks_1 = __importDefault(require("@jbrowse/core/util/calculateStaticBlocks"));
const tracks_1 = require("@jbrowse/core/util/tracks");
const mobx_1 = require("mobx");
const mobx_state_tree_1 = require("mobx-state-tree");
const Base1DViewModel_1 = __importDefault(require("@jbrowse/core/util/Base1DViewModel"));
const Base1DUtils_1 = require("@jbrowse/core/util/Base1DUtils");
const file_saver_1 = require("file-saver");
const clone_1 = __importDefault(require("clone"));
// icons
const Icons_1 = require("@jbrowse/core/ui/Icons");
const SyncAlt_1 = __importDefault(require("@mui/icons-material/SyncAlt"));
const Visibility_1 = __importDefault(require("@mui/icons-material/Visibility"));
const Label_1 = __importDefault(require("@mui/icons-material/Label"));
const FolderOpen_1 = __importDefault(require("@mui/icons-material/FolderOpen"));
const PhotoCamera_1 = __importDefault(require("@mui/icons-material/PhotoCamera"));
const ZoomIn_1 = __importDefault(require("@mui/icons-material/ZoomIn"));
const MenuOpen_1 = __importDefault(require("@mui/icons-material/MenuOpen"));
const Palette_1 = __importDefault(require("@mui/icons-material/Palette"));
const Search_1 = __importDefault(require("@mui/icons-material/Search"));
const MiniControls_1 = __importDefault(require("./components/MiniControls"));
const Header_1 = __importDefault(require("./components/Header"));
const util_2 = require("./util");
const searchUtils_1 = require("../searchUtils");
const consts_1 = require("./consts");
// lazies
const ReturnToImportFormDialog = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('@jbrowse/core/ui/ReturnToImportFormDialog'))));
const SequenceSearchDialog = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('./components/SequenceSearchDialog'))));
const ExportSvgDialog = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('./components/ExportSvgDialog'))));
const GetSequenceDialog = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('./components/GetSequenceDialog'))));
const SearchResultsDialog = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('./components/SearchResultsDialog'))));
function calculateVisibleLocStrings(contentBlocks) {
    if (!contentBlocks.length) {
        return '';
    }
    const isSingleAssemblyName = contentBlocks.every(b => b.assemblyName === contentBlocks[0].assemblyName);
    const locs = contentBlocks.map(block => (0, util_1.assembleLocString)({
        ...block,
        start: Math.round(block.start),
        end: Math.round(block.end),
        assemblyName: isSingleAssemblyName ? undefined : block.assemblyName,
    }));
    return locs.join(' ');
}
/**
 * #stateModel LinearGenomeView
 * #category view
 *
 * extends
 * - [BaseViewModel](../baseviewmodel)
 */
function stateModelFactory(pluginManager) {
    return mobx_state_tree_1.types
        .compose('LinearGenomeView', models_1.BaseViewModel, mobx_state_tree_1.types.model({
        /**
         * #property
         */
        id: mst_1.ElementId,
        /**
         * #property
         * this is a string instead of the const literal 'LinearGenomeView' to
         * reduce some typescripting strictness, but you should pass the string
         * 'LinearGenomeView' to the model explicitly
         */
        type: mobx_state_tree_1.types.literal('LinearGenomeView'),
        /**
         * #property
         * corresponds roughly to the horizontal scroll of the LGV
         */
        offsetPx: 0,
        /**
         * #property
         * corresponds roughly to the zoom level, base-pairs per pixel
         */
        bpPerPx: 1,
        /**
         * #property
         * currently displayed regions, can be a single chromosome, arbitrary
         * subsections, or the entire  set of chromosomes in the genome, but it not
         * advised to use the entire set of chromosomes if your assembly is very
         * fragmented
         */
        displayedRegions: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.frozen(), []),
        /**
         * #property
         * array of currently displayed tracks state models instances
         */
        tracks: mobx_state_tree_1.types.array(pluginManager.pluggableMstType('track', 'stateModel')),
        /**
         * #property
         */
        hideHeader: false,
        /**
         * #property
         */
        hideHeaderOverview: false,
        /**
         * #property
         */
        hideNoTracksActive: false,
        /**
         * #property
         */
        trackSelectorType: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.enumeration(['hierarchical']), 'hierarchical'),
        /**
         * #property
         * show the "center line"
         */
        showCenterLine: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, () => Boolean(JSON.parse((0, util_1.localStorageGetItem)('lgv-showCenterLine') || 'false'))),
        /**
         * #property
         * show the "cytobands" in the overview scale bar
         */
        showCytobandsSetting: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, () => Boolean(JSON.parse((0, util_1.localStorageGetItem)('lgv-showCytobands') || 'true'))),
        /**
         * #property
         * how to display the track labels, can be "overlapping", "offset", or
         * "hidden", or empty string "" (which results in conf being used). see
         * LinearGenomeViewPlugin
         * https://jbrowse.org/jb2/docs/config/lineargenomeviewplugin/ docs for
         * how conf is used
         */
        trackLabels: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, () => (0, util_1.localStorageGetItem)('lgv-trackLabels') || ''),
        /**
         * #property
         * show the "gridlines" in the track area
         */
        showGridlines: true,
        /**
         * #property
         * highlights on the LGV from the URL parameters
         */
        highlight: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.array(mobx_state_tree_1.types.frozen()), []),
        /**
         * #property
         * color by CDS
         */
        colorByCDS: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, () => Boolean(JSON.parse((0, util_1.localStorageGetItem)('lgv-colorByCDS') || 'false'))),
        /**
         * #property
         * color by CDS
         */
        showTrackOutlines: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, () => Boolean(JSON.parse((0, util_1.localStorageGetItem)('lgv-showTrackOutlines') || 'true'))),
    }))
        .volatile(() => ({
        volatileWidth: undefined,
        minimumBlockWidth: 3,
        draggingTrackId: undefined,
        volatileError: undefined,
        // array of callbacks to run after the next set of the displayedRegions,
        // which is basically like an onLoad
        afterDisplayedRegionsSetCallbacks: [],
        scaleFactor: 1,
        trackRefs: {},
        coarseDynamicBlocks: [],
        coarseTotalBp: 0,
        leftOffset: undefined,
        rightOffset: undefined,
    }))
        .views(self => ({
        /**
         * #getter
         * this is the effective value of the track labels setting, incorporating
         * both the config and view state. use this instead of view.trackLabels
         */
        get trackLabelsSetting() {
            const sessionSetting = (0, configuration_1.getConf)((0, util_1.getSession)(self), [
                'LinearGenomeViewPlugin',
                'trackLabels',
            ]);
            return self.trackLabels || sessionSetting;
        },
        /**
         * #getter
         */
        get width() {
            if (self.volatileWidth === undefined) {
                throw new Error('width undefined, make sure to check for model.initialized');
            }
            return self.volatileWidth;
        },
        /**
         * #getter
         */
        get interRegionPaddingWidth() {
            return consts_1.INTER_REGION_PADDING_WIDTH;
        },
        /**
         * #getter
         */
        get assemblyNames() {
            return [
                ...new Set(self.displayedRegions.map(region => region.assemblyName)),
            ];
        },
    }))
        .views(self => ({
        /**
         * #method
         */
        scaleBarDisplayPrefix() {
            return (0, mobx_state_tree_1.getParent)(self, 2).type === 'LinearSyntenyView'
                ? self.assemblyNames[0]
                : '';
        },
        /**
         * #method
         */
        MiniControlsComponent() {
            return MiniControls_1.default;
        },
        /**
         * #method
         */
        HeaderComponent() {
            return Header_1.default;
        },
        /**
         * #getter
         */
        get assemblyErrors() {
            const { assemblyManager } = (0, util_1.getSession)(self);
            return self.assemblyNames
                .map(a => { var _a; return (_a = assemblyManager.get(a)) === null || _a === void 0 ? void 0 : _a.error; })
                .filter(f => !!f)
                .join(', ');
        },
        /**
         * #getter
         */
        get assembliesInitialized() {
            const { assemblyManager } = (0, util_1.getSession)(self);
            const { assemblyNames } = self;
            return assemblyNames.every(a => { var _a; return (_a = assemblyManager.get(a)) === null || _a === void 0 ? void 0 : _a.initialized; });
        },
        /**
         * #getter
         */
        get initialized() {
            return self.volatileWidth !== undefined && this.assembliesInitialized;
        },
        /**
         * #getter
         */
        get hasDisplayedRegions() {
            return self.displayedRegions.length > 0;
        },
        /**
         * #getter
         */
        get scaleBarHeight() {
            return consts_1.SCALE_BAR_HEIGHT + consts_1.RESIZE_HANDLE_HEIGHT;
        },
        /**
         * #getter
         */
        get headerHeight() {
            if (self.hideHeader) {
                return 0;
            }
            if (self.hideHeaderOverview) {
                return consts_1.HEADER_BAR_HEIGHT;
            }
            return consts_1.HEADER_BAR_HEIGHT + consts_1.HEADER_OVERVIEW_HEIGHT;
        },
        /**
         * #getter
         */
        get trackHeights() {
            return (0, util_1.sum)(self.tracks.map(t => t.displays[0].height));
        },
        /**
         * #getter
         */
        get trackHeightsWithResizeHandles() {
            return this.trackHeights + self.tracks.length * consts_1.RESIZE_HANDLE_HEIGHT;
        },
        /**
         * #getter
         */
        get height() {
            return (this.trackHeightsWithResizeHandles +
                this.headerHeight +
                this.scaleBarHeight);
        },
        /**
         * #getter
         */
        get totalBp() {
            return (0, util_1.sum)(self.displayedRegions.map(r => r.end - r.start));
        },
        /**
         * #getter
         */
        get maxBpPerPx() {
            return this.totalBp / (self.width * 0.9);
        },
        /**
         * #getter
         */
        get minBpPerPx() {
            return 1 / 50;
        },
        /**
         * #getter
         */
        get error() {
            return self.volatileError || this.assemblyErrors;
        },
        /**
         * #getter
         */
        get maxOffset() {
            // objectively determined to keep the linear genome on the main screen
            const leftPadding = 10;
            return this.displayedRegionsTotalPx - leftPadding;
        },
        /**
         * #getter
         */
        get minOffset() {
            // objectively determined to keep the linear genome on the main screen
            const rightPadding = 30;
            return -self.width + rightPadding;
        },
        /**
         * #getter
         */
        get displayedRegionsTotalPx() {
            return this.totalBp / self.bpPerPx;
        },
        /**
         * #method
         */
        renderProps() {
            return {
                ...(0, tracks_1.getParentRenderProps)(self),
                bpPerPx: self.bpPerPx,
                colorByCDS: self.colorByCDS,
            };
        },
        /**
         * #method
         */
        searchScope(assemblyName) {
            return {
                assemblyName,
                includeAggregateIndexes: true,
                tracks: self.tracks,
            };
        },
        /**
         * #method
         */
        getTrack(id) {
            return self.tracks.find(t => t.configuration.trackId === id);
        },
        /**
         * #method
         */
        rankSearchResults(results) {
            // order of rank
            const openTrackIds = new Set(self.tracks.map(track => track.configuration.trackId));
            for (const result of results) {
                if (openTrackIds.has(result.trackId)) {
                    result.updateScore(result.getScore() + 1);
                }
            }
            return results;
        },
        /**
         * #method
         * modifies view menu action onClick to apply to all tracks of same type
         */
        rewriteOnClicks(trackType, viewMenuActions) {
            viewMenuActions.forEach(action => {
                // go to lowest level menu
                if ('subMenu' in action) {
                    this.rewriteOnClicks(trackType, action.subMenu);
                }
                if ('onClick' in action) {
                    const holdOnClick = action.onClick;
                    action.onClick = (...args) => {
                        self.tracks.forEach(track => {
                            if (track.type === trackType) {
                                holdOnClick.apply(track, [track, ...args]);
                            }
                        });
                    };
                }
            });
        },
        /**
         * #getter
         */
        get trackTypeActions() {
            const allActions = new Map();
            self.tracks.forEach(track => {
                const trackInMap = allActions.get(track.type);
                if (!trackInMap) {
                    const viewMenuActions = (0, clone_1.default)(track.viewMenuActions);
                    this.rewriteOnClicks(track.type, viewMenuActions);
                    allActions.set(track.type, viewMenuActions);
                }
            });
            return allActions;
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        setShowTrackOutlines(arg) {
            self.showTrackOutlines = arg;
        },
        /**
         * #action
         */
        setColorByCDS(flag) {
            self.colorByCDS = flag;
        },
        /**
         * #action
         */
        setShowCytobands(flag) {
            self.showCytobandsSetting = flag;
        },
        /**
         * #action
         */
        setWidth(newWidth) {
            self.volatileWidth = newWidth;
        },
        /**
         * #action
         */
        setError(error) {
            self.volatileError = error;
        },
        /**
         * #action
         */
        setHideHeader(b) {
            self.hideHeader = b;
        },
        /**
         * #action
         */
        setHideHeaderOverview(b) {
            self.hideHeaderOverview = b;
        },
        /**
         * #action
         */
        setHideNoTracksActive(b) {
            self.hideNoTracksActive = b;
        },
        /**
         * #action
         */
        setShowGridlines(b) {
            self.showGridlines = b;
        },
        /**
         * #action
         */
        addToHighlights(highlight) {
            self.highlight.push(highlight);
        },
        /**
         * #action
         */
        setHighlight(highlight) {
            self.highlight = (0, mobx_state_tree_1.cast)(highlight);
        },
        /**
         * #action
         */
        removeHighlight(highlight) {
            self.highlight.remove(highlight);
        },
        /**
         * #action
         */
        scrollTo(offsetPx) {
            const newOffsetPx = (0, util_1.clamp)(offsetPx, self.minOffset, self.maxOffset);
            self.offsetPx = newOffsetPx;
            return newOffsetPx;
        },
        /**
         * #action
         */
        zoomTo(bpPerPx, offset = self.width / 2, centerAtOffset = false) {
            const newBpPerPx = (0, util_1.clamp)(bpPerPx, self.minBpPerPx, self.maxBpPerPx);
            if (newBpPerPx === self.bpPerPx) {
                return newBpPerPx;
            }
            const oldBpPerPx = self.bpPerPx;
            if (Math.abs(oldBpPerPx - newBpPerPx) < 0.000001) {
                console.warn('zoomTo bpPerPx rounding error');
                return oldBpPerPx;
            }
            self.bpPerPx = newBpPerPx;
            // tweak the offset so that the center of the view remains at the same
            // coordinate
            this.scrollTo(Math.round(((self.offsetPx + offset) * oldBpPerPx) / newBpPerPx -
                (centerAtOffset ? self.width / 2 : offset)));
            return newBpPerPx;
        },
        /**
         * #action
         * sets offsets of rubberband, used in the get sequence dialog can call
         * view.getSelectedRegions(view.leftOffset,view.rightOffset) to compute
         * the selected regions from the offsets
         */
        setOffsets(left, right) {
            self.leftOffset = left;
            self.rightOffset = right;
        },
        /**
         * #action
         */
        setSearchResults(searchResults, searchQuery, assemblyName) {
            (0, util_1.getSession)(self).queueDialog(handleClose => [
                SearchResultsDialog,
                {
                    model: self,
                    searchResults,
                    searchQuery,
                    handleClose,
                    assemblyName,
                },
            ]);
        },
        /**
         * #action
         */
        setNewView(bpPerPx, offsetPx) {
            this.zoomTo(bpPerPx);
            this.scrollTo(offsetPx);
        },
        /**
         * #action
         */
        horizontallyFlip() {
            self.displayedRegions = (0, mobx_state_tree_1.cast)([...self.displayedRegions]
                .reverse()
                .map(region => ({ ...region, reversed: !region.reversed })));
            this.scrollTo(self.totalBp / self.bpPerPx - self.offsetPx - self.width);
        },
        /**
         * #action
         */
        showTrack(trackId, initialSnapshot = {}, displayInitialSnapshot = {}) {
            const schema = pluginManager.pluggableConfigSchemaType('track');
            const conf = (0, mobx_state_tree_1.resolveIdentifier)(schema, (0, mobx_state_tree_1.getRoot)(self), trackId);
            if (!conf) {
                throw new Error(`Could not resolve identifier "${trackId}"`);
            }
            const trackType = pluginManager.getTrackType(conf === null || conf === void 0 ? void 0 : conf.type);
            if (!trackType) {
                throw new Error(`Unknown track type ${conf.type}`);
            }
            const viewType = pluginManager.getViewType(self.type);
            const supportedDisplays = new Set(viewType.displayTypes.map(d => d.name));
            const displayConf = conf.displays.find((d) => supportedDisplays.has(d.type));
            if (!displayConf) {
                throw new Error(`Could not find a compatible display for view type ${self.type}`);
            }
            const t = self.tracks.filter(t => t.configuration === conf);
            if (t.length === 0) {
                const track = trackType.stateModel.create({
                    ...initialSnapshot,
                    type: conf.type,
                    configuration: conf,
                    displays: [
                        {
                            type: displayConf.type,
                            configuration: displayConf,
                            ...displayInitialSnapshot,
                        },
                    ],
                });
                self.tracks.push(track);
                return track;
            }
            return t[0];
        },
        /**
         * #action
         */
        hideTrack(trackId) {
            const schema = pluginManager.pluggableConfigSchemaType('track');
            const conf = (0, mobx_state_tree_1.resolveIdentifier)(schema, (0, mobx_state_tree_1.getRoot)(self), trackId);
            const t = self.tracks.filter(t => t.configuration === conf);
            (0, mobx_1.transaction)(() => {
                t.forEach(t => self.tracks.remove(t));
            });
            return t.length;
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        moveTrackDown(id) {
            const idx = self.tracks.findIndex(v => v.id === id);
            if (idx === -1) {
                return;
            }
            if (idx !== -1 && idx < self.tracks.length - 1) {
                self.tracks.splice(idx, 2, self.tracks[idx + 1], self.tracks[idx]);
            }
        },
        /**
         * #action
         */
        moveTrackUp(id) {
            const idx = self.tracks.findIndex(track => track.id === id);
            if (idx > 0) {
                self.tracks.splice(idx - 1, 2, self.tracks[idx], self.tracks[idx - 1]);
            }
        },
        /**
         * #action
         */
        moveTrackToTop(id) {
            const idx = self.tracks.findIndex(track => track.id === id);
            self.tracks = (0, mobx_state_tree_1.cast)([
                self.tracks[idx],
                ...self.tracks.filter(track => track.id !== id),
            ]);
        },
        /**
         * #action
         */
        moveTrackToBottom(id) {
            const idx = self.tracks.findIndex(track => track.id === id);
            self.tracks = (0, mobx_state_tree_1.cast)([
                ...self.tracks.filter(track => track.id !== id),
                self.tracks[idx],
            ]);
        },
        /**
         * #action
         */
        moveTrack(movingId, targetId) {
            const oldIndex = self.tracks.findIndex(track => track.id === movingId);
            if (oldIndex === -1) {
                throw new Error(`Track ID ${movingId} not found`);
            }
            const newIndex = self.tracks.findIndex(track => track.id === targetId);
            if (newIndex === -1) {
                throw new Error(`Track ID ${targetId} not found`);
            }
            const tracks = self.tracks.filter((_, idx) => idx !== oldIndex);
            tracks.splice(newIndex, 0, self.tracks[oldIndex]);
            self.tracks = (0, mobx_state_tree_1.cast)(tracks);
        },
        /**
         * #action
         */
        toggleTrack(trackId) {
            // if we have any tracks with that configuration, turn them off
            const hiddenCount = self.hideTrack(trackId);
            // if none had that configuration, turn one on
            if (!hiddenCount) {
                self.showTrack(trackId);
                return true;
            }
            return false;
        },
        /**
         * #action
         */
        setTrackLabels(setting) {
            localStorage.setItem('lgv-trackLabels', setting);
            self.trackLabels = setting;
        },
        /**
         * #action
         */
        setShowCenterLine(b) {
            self.showCenterLine = b;
        },
        /**
         * #action
         */
        setDisplayedRegions(regions) {
            self.displayedRegions = (0, mobx_state_tree_1.cast)(regions);
            self.zoomTo(self.bpPerPx);
        },
        /**
         * #action
         */
        activateTrackSelector() {
            if (self.trackSelectorType === 'hierarchical') {
                const session = (0, util_1.getSession)(self);
                if ((0, util_1.isSessionModelWithWidgets)(session)) {
                    const selector = session.addWidget('HierarchicalTrackSelectorWidget', 'hierarchicalTrackSelector', { view: self });
                    session.showWidget(selector);
                    return selector;
                }
            }
            throw new Error(`invalid track selector type ${self.trackSelectorType}`);
        },
        /**
         * #method
         * Helper method for the fetchSequence.
         * Retrieves the corresponding regions that were selected by the
         * rubberband
         *
         * @param leftOffset - `object as {start, end, index, offset}`, offset = start
         * of user drag
         * @param rightOffset - `object as {start, end, index, offset}`,
         * offset = end of user drag
         * @returns array of Region[]
         */
        getSelectedRegions(leftOffset, rightOffset) {
            const snap = (0, mobx_state_tree_1.getSnapshot)(self);
            const simView = Base1DViewModel_1.default.create({
                ...snap,
                interRegionPaddingWidth: self.interRegionPaddingWidth,
            });
            simView.setVolatileWidth(self.width);
            simView.moveTo(leftOffset, rightOffset);
            return simView.dynamicBlocks.contentBlocks.map(region => ({
                ...region,
                start: Math.floor(region.start),
                end: Math.ceil(region.end),
            }));
        },
        /**
         * #action
         * schedule something to be run after the next time displayedRegions is
         * set
         */
        afterDisplayedRegionsSet(cb) {
            self.afterDisplayedRegionsSetCallbacks.push(cb);
        },
        /**
         * #action
         */
        horizontalScroll(distance) {
            const oldOffsetPx = self.offsetPx;
            // newOffsetPx is the actual offset after the scroll is clamped
            const newOffsetPx = self.scrollTo(self.offsetPx + distance);
            return newOffsetPx - oldOffsetPx;
        },
        /**
         * #action
         */
        center() {
            const centerBp = self.totalBp / 2;
            const centerPx = centerBp / self.bpPerPx;
            self.scrollTo(Math.round(centerPx - self.width / 2));
        },
        /**
         * #action
         */
        showAllRegions() {
            self.zoomTo(self.maxBpPerPx);
            this.center();
        },
        /**
         * #action
         */
        showAllRegionsInAssembly(assemblyName) {
            const session = (0, util_1.getSession)(self);
            const { assemblyManager } = session;
            if (!assemblyName) {
                const names = new Set(self.displayedRegions.map(r => r.assemblyName));
                if (names.size > 1) {
                    session.notify(`Can't perform operation with multiple assemblies currently`);
                    return;
                }
                ;
                [assemblyName] = [...names];
            }
            const assembly = assemblyManager.get(assemblyName);
            if (assembly) {
                const { regions } = assembly;
                if (regions) {
                    this.setDisplayedRegions(regions);
                    self.zoomTo(self.maxBpPerPx);
                    this.center();
                }
            }
        },
        /**
         * #action
         */
        setDraggingTrackId(idx) {
            self.draggingTrackId = idx;
        },
        /**
         * #action
         */
        setScaleFactor(factor) {
            self.scaleFactor = factor;
        },
        /**
         * #action
         * this "clears the view" and makes the view return to the import form
         */
        clearView() {
            this.setDisplayedRegions([]);
            self.tracks.clear();
            // it is necessary to run these after setting displayed regions empty
            // or else model.offsetPx gets set to Infinity and breaks
            // mobx-state-tree snapshot
            self.scrollTo(0);
            self.zoomTo(10);
        },
        /**
         * #method
         * creates an svg export and save using FileSaver
         */
        async exportSvg(opts = {}) {
            const { renderToSvg } = await Promise.resolve().then(() => __importStar(require('./svgcomponents/SVGLinearGenomeView')));
            const html = await renderToSvg(self, opts);
            const blob = new Blob([html], { type: 'image/svg+xml' });
            (0, file_saver_1.saveAs)(blob, opts.filename || 'image.svg');
        },
    }))
        .actions(self => {
        let cancelLastAnimation = () => { };
        /**
         * #action
         * perform animated slide
         */
        function slide(viewWidths) {
            const [animate, cancelAnimation] = (0, util_1.springAnimate)(self.offsetPx, self.offsetPx + self.width * viewWidths, self.scrollTo, undefined, undefined, 200);
            cancelLastAnimation();
            cancelLastAnimation = cancelAnimation;
            animate();
        }
        return { slide };
    })
        .actions(self => {
        let cancelLastAnimation = () => { };
        /**
         * #action
         * perform animated zoom
         */
        function zoom(targetBpPerPx) {
            self.zoomTo(self.bpPerPx);
            if (
            // already zoomed all the way in
            (targetBpPerPx < self.bpPerPx && self.bpPerPx === self.minBpPerPx) ||
                // already zoomed all the way out
                (targetBpPerPx > self.bpPerPx && self.bpPerPx === self.maxBpPerPx)) {
                return;
            }
            const factor = self.bpPerPx / targetBpPerPx;
            const [animate, cancelAnimation] = (0, util_1.springAnimate)(1, factor, self.setScaleFactor, () => {
                self.zoomTo(targetBpPerPx);
                self.setScaleFactor(1);
            });
            cancelLastAnimation();
            cancelLastAnimation = cancelAnimation;
            animate();
        }
        return { zoom };
    })
        .views(self => ({
        /**
         * #getter
         */
        get canShowCytobands() {
            return self.displayedRegions.length === 1 && this.anyCytobandsExist;
        },
        /**
         * #getter
         */
        get showCytobands() {
            return this.canShowCytobands && self.showCytobandsSetting;
        },
        /**
         * #getter
         */
        get anyCytobandsExist() {
            const { assemblyManager } = (0, util_1.getSession)(self);
            return self.assemblyNames.some(a => { var _a, _b; return (_b = (_a = assemblyManager.get(a)) === null || _a === void 0 ? void 0 : _a.cytobands) === null || _b === void 0 ? void 0 : _b.length; });
        },
        /**
         * #getter
         * the cytoband is displayed to the right of the chromosome name, and
         * that offset is calculated manually with this method
         */
        get cytobandOffset() {
            var _a;
            return this.showCytobands
                ? (0, util_1.measureText)(((_a = self.displayedRegions[0]) === null || _a === void 0 ? void 0 : _a.refName) || '', 12) + 15
                : 0;
        },
    }))
        .views(self => ({
        /**
         * #method
         * return the view menu items
         */
        menuItems() {
            const { canShowCytobands, showCytobands } = self;
            const session = (0, util_1.getSession)(self);
            const menuItems = [
                {
                    label: 'Return to import form',
                    onClick: () => {
                        (0, util_1.getSession)(self).queueDialog(handleClose => [
                            ReturnToImportFormDialog,
                            { model: self, handleClose },
                        ]);
                    },
                    icon: FolderOpen_1.default,
                },
                ...((0, util_1.isSessionWithAddTracks)(session)
                    ? [
                        {
                            label: 'Sequence search',
                            icon: Search_1.default,
                            onClick: () => {
                                (0, util_1.getSession)(self).queueDialog(handleClose => [
                                    SequenceSearchDialog,
                                    { model: self, handleClose },
                                ]);
                            },
                        },
                    ]
                    : []),
                {
                    label: 'Export SVG',
                    icon: PhotoCamera_1.default,
                    onClick: () => {
                        (0, util_1.getSession)(self).queueDialog(handleClose => [
                            ExportSvgDialog,
                            { model: self, handleClose },
                        ]);
                    },
                },
                {
                    label: 'Open track selector',
                    onClick: self.activateTrackSelector,
                    icon: Icons_1.TrackSelector,
                },
                {
                    label: 'Horizontally flip',
                    icon: SyncAlt_1.default,
                    onClick: self.horizontallyFlip,
                },
                {
                    label: 'Color by CDS',
                    type: 'checkbox',
                    checked: self.colorByCDS,
                    icon: Palette_1.default,
                    onClick: () => {
                        self.setColorByCDS(!self.colorByCDS);
                    },
                },
                {
                    label: 'Show...',
                    icon: Visibility_1.default,
                    subMenu: [
                        {
                            label: 'Show all regions in assembly',
                            onClick: self.showAllRegionsInAssembly,
                        },
                        {
                            label: 'Show center line',
                            type: 'checkbox',
                            checked: self.showCenterLine,
                            onClick: () => {
                                self.setShowCenterLine(!self.showCenterLine);
                            },
                        },
                        {
                            label: 'Show header',
                            type: 'checkbox',
                            checked: !self.hideHeader,
                            onClick: () => {
                                self.setHideHeader(!self.hideHeader);
                            },
                        },
                        {
                            label: 'Show track outlines',
                            type: 'checkbox',
                            checked: self.showTrackOutlines,
                            onClick: () => {
                                self.setShowTrackOutlines(!self.showTrackOutlines);
                            },
                        },
                        {
                            label: 'Show header overview',
                            type: 'checkbox',
                            checked: !self.hideHeaderOverview,
                            onClick: () => {
                                self.setHideHeaderOverview(!self.hideHeaderOverview);
                            },
                            disabled: self.hideHeader,
                        },
                        {
                            label: 'Show no tracks active button',
                            type: 'checkbox',
                            checked: !self.hideNoTracksActive,
                            onClick: () => {
                                self.setHideNoTracksActive(!self.hideNoTracksActive);
                            },
                        },
                        {
                            label: 'Show guidelines',
                            type: 'checkbox',
                            checked: self.showGridlines,
                            onClick: () => {
                                self.setShowGridlines(!self.showGridlines);
                            },
                        },
                        ...(canShowCytobands
                            ? [
                                {
                                    label: 'Show ideogram',
                                    type: 'checkbox',
                                    checked: self.showCytobands,
                                    onClick: () => {
                                        self.setShowCytobands(!showCytobands);
                                    },
                                },
                            ]
                            : []),
                    ],
                },
                {
                    label: 'Track labels',
                    icon: Label_1.default,
                    subMenu: [
                        {
                            label: 'Overlapping',
                            icon: Visibility_1.default,
                            type: 'radio',
                            checked: self.trackLabelsSetting === 'overlapping',
                            onClick: () => {
                                self.setTrackLabels('overlapping');
                            },
                        },
                        {
                            label: 'Offset',
                            icon: Visibility_1.default,
                            type: 'radio',
                            checked: self.trackLabelsSetting === 'offset',
                            onClick: () => {
                                self.setTrackLabels('offset');
                            },
                        },
                        {
                            label: 'Hidden',
                            icon: Visibility_1.default,
                            type: 'radio',
                            checked: self.trackLabelsSetting === 'hidden',
                            onClick: () => {
                                self.setTrackLabels('hidden');
                            },
                        },
                    ],
                },
            ];
            // add track's view level menu options
            for (const [key, value] of self.trackTypeActions.entries()) {
                if (value.length) {
                    menuItems.push({ type: 'divider' }, { type: 'subHeader', label: key });
                    value.forEach(action => menuItems.push(action));
                }
            }
            return menuItems;
        },
    }))
        .views(self => {
        let currentlyCalculatedStaticBlocks;
        let stringifiedCurrentlyCalculatedStaticBlocks = '';
        return {
            /**
             * #getter
             * static blocks are an important concept jbrowse uses to avoid
             * re-rendering when you scroll to the side. when you horizontally
             * scroll to the right, old blocks to the left may be removed, and new
             * blocks may be instantiated on the right. tracks may use the static
             * blocks to render their data for the region represented by the block
             */
            get staticBlocks() {
                const ret = (0, calculateStaticBlocks_1.default)(self);
                const sret = JSON.stringify(ret);
                if (stringifiedCurrentlyCalculatedStaticBlocks !== sret) {
                    currentlyCalculatedStaticBlocks = ret;
                    stringifiedCurrentlyCalculatedStaticBlocks = sret;
                }
                return currentlyCalculatedStaticBlocks;
            },
            /**
             * #getter
             * dynamic blocks represent the exact coordinates of the currently
             * visible genome regions on the screen. they are similar to static
             * blocks, but static blocks can go offscreen while dynamic blocks
             * represent exactly what is on screen
             */
            get dynamicBlocks() {
                return (0, calculateDynamicBlocks_1.default)(self);
            },
            /**
             * #getter
             * rounded dynamic blocks are dynamic blocks without fractions of bp
             */
            get roundedDynamicBlocks() {
                return this.dynamicBlocks.contentBlocks.map(block => ({
                    ...block,
                    start: Math.floor(block.start),
                    end: Math.ceil(block.end),
                }));
            },
            /**
             * #getter
             * a single "combo-locstring" representing all the regions visible on
             * the screen
             */
            get visibleLocStrings() {
                return calculateVisibleLocStrings(this.dynamicBlocks.contentBlocks);
            },
            /**
             * #getter
             * same as visibleLocStrings, but only updated every 300ms
             */
            get coarseVisibleLocStrings() {
                return calculateVisibleLocStrings(self.coarseDynamicBlocks);
            },
        };
    })
        .actions(self => ({
        /**
         * #action
         */
        setCoarseDynamicBlocks(blocks) {
            self.coarseDynamicBlocks = blocks.contentBlocks;
            self.coarseTotalBp = blocks.totalBp;
        },
        afterAttach() {
            (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.autorun)(() => {
                if (self.initialized) {
                    this.setCoarseDynamicBlocks(self.dynamicBlocks);
                }
            }, { delay: 150 }));
            (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.autorun)(() => {
                const s = (s) => JSON.stringify(s);
                const { showCytobandsSetting, showCenterLine, colorByCDS } = self;
                (0, util_1.localStorageSetItem)('lgv-showCytobands', s(showCytobandsSetting));
                (0, util_1.localStorageSetItem)('lgv-showCenterLine', s(showCenterLine));
                (0, util_1.localStorageSetItem)('lgv-colorByCDS', s(colorByCDS));
            }));
        },
    }))
        .actions(self => ({
        /**
         * #action
         * offset is the base-pair-offset in the displayed region, index is the
         * index of the displayed region in the linear genome view
         *
         * @param start - object as `{start, end, offset, index}`
         * @param end - object as `{start, end, offset, index}`
         */
        moveTo(start, end) {
            (0, Base1DUtils_1.moveTo)(self, start, end);
        },
        /**
         * #action
         * Navigate to the given locstring, will change displayed regions if
         * needed, and wait for assemblies to be initialized
         *
         * @param input - e.g. "chr1:1-100", "chr1:1-100 chr2:1-100", "chr 1 100"
         * @param optAssemblyName - (optional) the assembly name to use when
         * navigating to the locstring
         */
        async navToLocString(input, optAssemblyName) {
            const { assemblyNames } = self;
            const { assemblyManager } = (0, util_1.getSession)(self);
            const assemblyName = optAssemblyName || assemblyNames[0];
            if (assemblyName) {
                await assemblyManager.waitForAssembly(assemblyName);
            }
            return this.navToLocations((0, util_2.parseLocStrings)(input, assemblyName, (ref, asm) => assemblyManager.isValidRefName(ref, asm)), assemblyName);
        },
        /**
         * #action
         * Performs a text index search, and navigates to it immediately if a
         * single result is returned. Will pop up a search dialog if multiple
         * results are returned
         */
        async navToSearchString({ input, assembly, }) {
            await (0, searchUtils_1.handleSelectedRegion)({
                input,
                assembly,
                model: self,
            });
        },
        /**
         * #action
         * Similar to `navToLocString`, but accepts parsed location objects
         * instead of strings. Will try to perform `setDisplayedRegions` if
         * changing regions
         */
        async navToLocations(parsedLocStrings, assemblyName) {
            const { assemblyManager } = (0, util_1.getSession)(self);
            await (0, mobx_1.when)(() => self.volatileWidth !== undefined);
            const locations = await (0, util_2.generateLocations)(parsedLocStrings, assemblyManager, assemblyName);
            if (locations.length === 1) {
                const loc = locations[0];
                const { reversed, parentRegion, start, end } = loc;
                self.setDisplayedRegions([{ reversed, ...parentRegion }]);
                this.navTo({
                    ...loc,
                    start: (0, util_1.clamp)(start !== null && start !== void 0 ? start : 0, 0, parentRegion.end),
                    end: (0, util_1.clamp)(end !== null && end !== void 0 ? end : parentRegion.end, 0, parentRegion.end),
                });
            }
            else {
                self.setDisplayedRegions(
                // @ts-expect-error
                locations.map(r => (r.start === undefined ? r.parentRegion : r)));
                self.showAllRegions();
            }
        },
        /**
         * #action
         * Navigate to a location based on its refName and optionally start, end,
         * and assemblyName. Will not try to change displayed regions, use
         * `navToLocations` instead. Only navigates to a location if it is
         * entirely within a displayedRegion. Navigates to the first matching
         * location encountered.
         *
         * Throws an error if navigation was unsuccessful
         *
         * @param query - a proposed location to navigate to
         */
        navTo(query) {
            this.navToMultiple([query]);
        },
        /**
         * #action
         * Navigate to a location based on its refName and optionally start, end,
         * and assemblyName. Will not try to change displayed regions, use
         * navToLocations instead. Only navigates to a location if it is entirely
         * within a displayedRegion. Navigates to the first matching location
         * encountered.
         *
         * Throws an error if navigation was unsuccessful
         *
         * @param locations - proposed location to navigate to
         */
        navToMultiple(locations) {
            if (locations.some(l => l.start !== undefined && l.end !== undefined && l.start > l.end)) {
                throw new Error('found start greater than end');
            }
            const f1 = locations.at(0);
            const f2 = locations.at(-1);
            if (!f1 || !f2) {
                return;
            }
            const a = self.assemblyNames[0];
            const { assemblyManager } = (0, util_1.getSession)(self);
            const assembly1 = assemblyManager.get(f1.assemblyName || a);
            const assembly2 = assemblyManager.get(f2.assemblyName || a);
            const ref1 = (assembly1 === null || assembly1 === void 0 ? void 0 : assembly1.getCanonicalRefName(f1.refName)) || f1.refName;
            const ref2 = (assembly2 === null || assembly2 === void 0 ? void 0 : assembly2.getCanonicalRefName(f2.refName)) || f2.refName;
            const r1 = self.displayedRegions.find(r => r.refName === ref1);
            const r2 = (0, util_1.findLast)(self.displayedRegions, r => r.refName === ref2);
            if (!r1) {
                throw new Error(`could not find a region with refName "${ref1}"`);
            }
            if (!r2) {
                throw new Error(`could not find a region with refName "${ref2}"`);
            }
            const s1 = f1.start === undefined ? r1.start : f1.start;
            const e1 = f1.end === undefined ? r1.end : f1.end;
            const s2 = f2.start === undefined ? r2.start : f2.start;
            const e2 = f2.end === undefined ? r2.end : f2.end;
            const index = self.displayedRegions.findIndex(r => ref1 === r.refName &&
                s1 >= r.start &&
                s1 <= r.end &&
                e1 <= r.end &&
                e1 >= r.start);
            const index2 = self.displayedRegions.findIndex(r => ref2 === r.refName &&
                s2 >= r.start &&
                s2 <= r.end &&
                e2 <= r.end &&
                e2 >= r.start);
            if (index === -1 || index2 === -1) {
                throw new Error(`could not find a region that contained "${locations.map(l => (0, util_1.assembleLocString)(l))}"`);
            }
            const sd = self.displayedRegions[index];
            const ed = self.displayedRegions[index2];
            this.moveTo({
                index,
                offset: sd.reversed ? sd.end - e1 : s1 - sd.start,
            }, {
                index: index2,
                offset: ed.reversed ? ed.end - s2 : e2 - ed.start,
            });
        },
    }))
        .views(self => ({
        /**
         * #method
         */
        rubberBandMenuItems() {
            return [
                {
                    label: 'Zoom to region',
                    icon: ZoomIn_1.default,
                    onClick: () => {
                        self.moveTo(self.leftOffset, self.rightOffset);
                    },
                },
                {
                    label: 'Get sequence',
                    icon: MenuOpen_1.default,
                    onClick: () => {
                        (0, util_1.getSession)(self).queueDialog(handleClose => [
                            GetSequenceDialog,
                            { model: self, handleClose },
                        ]);
                    },
                },
            ];
        },
        /**
         * #method
         */
        bpToPx({ refName, coord, regionNumber, }) {
            return (0, Base1DUtils_1.bpToPx)({ refName, coord, regionNumber, self });
        },
        /**
         * #method
         * scrolls the view to center on the given bp. if that is not in any of
         * the displayed regions, does nothing
         *
         * @param coord - basepair at which you want to center the view
         * @param refName - refName of the displayedRegion you are centering at
         * @param regionNumber - index of the displayedRegion
         */
        centerAt(coord, refName, regionNumber) {
            const centerPx = this.bpToPx({
                refName,
                coord,
                regionNumber,
            });
            if (centerPx !== undefined) {
                self.scrollTo(Math.round(centerPx.offsetPx - self.width / 2));
            }
        },
        /**
         * #method
         */
        pxToBp(px) {
            return (0, Base1DUtils_1.pxToBp)(self, px);
        },
        /**
         * #getter
         */
        get centerLineInfo() {
            return self.displayedRegions.length > 0
                ? this.pxToBp(self.width / 2)
                : undefined;
        },
    }))
        .actions(self => ({
        afterCreate() {
            function handler(e) {
                const session = (0, util_1.getSession)(self);
                if (session.focusedViewId === self.id && (e.ctrlKey || e.metaKey)) {
                    if (e.code === 'ArrowLeft') {
                        e.preventDefault();
                        self.slide(-0.9);
                    }
                    else if (e.code === 'ArrowRight') {
                        e.preventDefault();
                        self.slide(0.9);
                    }
                    else if (e.code === 'ArrowUp' && self.scaleFactor === 1) {
                        e.preventDefault();
                        self.zoom(self.bpPerPx / 2);
                    }
                    else if (e.code === 'ArrowDown' && self.scaleFactor === 1) {
                        e.preventDefault();
                        self.zoom(self.bpPerPx * 2);
                    }
                }
            }
            document.addEventListener('keydown', handler);
            (0, mobx_state_tree_1.addDisposer)(self, () => {
                document.removeEventListener('keydown', handler);
            });
        },
    }))
        .preProcessSnapshot(snap => {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!snap) {
            return snap;
        }
        const { highlight, ...rest } = snap;
        return {
            highlight: Array.isArray(highlight) || highlight === undefined
                ? highlight
                : [highlight],
            ...rest,
        };
    });
}
var LinearGenomeView_1 = require("./components/LinearGenomeView");
Object.defineProperty(exports, "ReactComponent", { enumerable: true, get: function () { return __importDefault(LinearGenomeView_1).default; } });
Object.defineProperty(exports, "LinearGenomeView", { enumerable: true, get: function () { return __importDefault(LinearGenomeView_1).default; } });
var RefNameAutocomplete_1 = require("./components/RefNameAutocomplete");
Object.defineProperty(exports, "RefNameAutocomplete", { enumerable: true, get: function () { return __importDefault(RefNameAutocomplete_1).default; } });
var SearchBox_1 = require("./components/SearchBox");
Object.defineProperty(exports, "SearchBox", { enumerable: true, get: function () { return __importDefault(SearchBox_1).default; } });
var ZoomControls_1 = require("./components/ZoomControls");
Object.defineProperty(exports, "ZoomControls", { enumerable: true, get: function () { return __importDefault(ZoomControls_1).default; } });
var SVGLinearGenomeView_1 = require("./svgcomponents/SVGLinearGenomeView");
Object.defineProperty(exports, "renderToSvg", { enumerable: true, get: function () { return SVGLinearGenomeView_1.renderToSvg; } });
