"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const mobx_react_1 = require("mobx-react");
const util_1 = require("@jbrowse/core/util");
const BaseResults_1 = __importStar(require("@jbrowse/core/TextSearch/BaseResults"));
const material_1 = require("@mui/material");
const util_2 = require("./util");
const AutocompleteTextField_1 = __importDefault(require("./AutocompleteTextField"));
const RefNameAutocomplete = (0, mobx_react_1.observer)(function ({ model, onSelect, assemblyName, style, fetchResults, onChange, value, showHelp = true, minWidth = 200, maxWidth = 550, TextFieldProps = {}, }) {
    const session = (0, util_1.getSession)(model);
    const { assemblyManager } = session;
    const [open, setOpen] = (0, react_1.useState)(false);
    const [loaded, setLoaded] = (0, react_1.useState)(true);
    const [currentSearch, setCurrentSearch] = (0, react_1.useState)('');
    const [inputValue, setInputValue] = (0, react_1.useState)('');
    const [searchOptions, setSearchOptions] = (0, react_1.useState)();
    const debouncedSearch = (0, util_1.useDebounce)(currentSearch, 300);
    const assembly = assemblyName ? assemblyManager.get(assemblyName) : undefined;
    const { coarseVisibleLocStrings, hasDisplayedRegions } = model;
    (0, react_1.useEffect)(() => {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        ;
        (async () => {
            try {
                if (debouncedSearch === '' || !assemblyName) {
                    return;
                }
                setLoaded(false);
                const results = await fetchResults(debouncedSearch);
                setLoaded(true);
                setSearchOptions((0, util_2.getDeduplicatedResult)(results));
            }
            catch (e) {
                console.error(e);
                session.notifyError(`${e}`, e);
            }
        })();
    }, [assemblyName, fetchResults, debouncedSearch, session]);
    const inputBoxVal = coarseVisibleLocStrings || value || '';
    // heuristic, text width + 60 accommodates help icon and search icon
    const width = Math.min(Math.max((0, util_1.measureText)(inputBoxVal, 14) + 100, minWidth), maxWidth);
    const refNames = assembly === null || assembly === void 0 ? void 0 : assembly.refNames;
    const regionOptions = (refNames === null || refNames === void 0 ? void 0 : refNames.map(refName => ({
        result: new BaseResults_1.RefSequenceResult({
            refName,
            label: refName,
            matchedAttribute: 'refName',
        }),
    }))) || [];
    // notes on implementation:
    // The selectOnFocus setting helps highlight the field when clicked
    return (react_1.default.createElement(material_1.Autocomplete, { "data-testid": "autocomplete", disableListWrap: true, disableClearable: true, disabled: !assemblyName, freeSolo: true, includeInputInList: true, selectOnFocus: true, style: { ...style, width }, value: inputBoxVal, loading: !loaded, inputValue: inputValue, onInputChange: (_event, newInputValue) => {
            setInputValue(newInputValue);
            onChange === null || onChange === void 0 ? void 0 : onChange(newInputValue);
        }, loadingText: "loading results", open: open, onOpen: () => {
            setOpen(true);
        }, onClose: () => {
            setOpen(false);
            setLoaded(true);
            if (hasDisplayedRegions) {
                setCurrentSearch('');
                setSearchOptions(undefined);
            }
        }, onChange: (_event, selectedOption) => {
            if (!selectedOption || !assemblyName) {
                return;
            }
            if (typeof selectedOption === 'string') {
                // handles string inputs on keyPress enter
                onSelect === null || onSelect === void 0 ? void 0 : onSelect(new BaseResults_1.default({ label: selectedOption }));
            }
            else {
                onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectedOption.result);
            }
            setInputValue(inputBoxVal);
        }, options: (searchOptions === null || searchOptions === void 0 ? void 0 : searchOptions.length) ? searchOptions : regionOptions, getOptionDisabled: option => option.group === 'limitOption', filterOptions: (opts, { inputValue }) => (0, util_2.getFiltered)(opts, inputValue), renderInput: params => (react_1.default.createElement(AutocompleteTextField_1.default, { showHelp: showHelp, params: params, inputBoxVal: inputBoxVal, TextFieldProps: TextFieldProps, setCurrentSearch: setCurrentSearch, setInputValue: setInputValue })), getOptionLabel: opt => typeof opt === 'string' ? opt : opt.result.getDisplayString() }));
});
exports.default = RefNameAutocomplete;
