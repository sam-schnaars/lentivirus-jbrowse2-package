"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const QuickLRU_1 = __importDefault(require("../util/QuickLRU"));
const configuration_1 = require("../configuration");
class TextSearchManager {
    constructor(pluginManager) {
        this.pluginManager = pluginManager;
        this.adapterCache = new QuickLRU_1.default({
            maxSize: 15,
        });
    }
    loadTextSearchAdapters(searchScope) {
        return Promise.all(this.relevantAdapters(searchScope).map(async (conf) => {
            const adapterId = (0, configuration_1.readConfObject)(conf, 'textSearchAdapterId');
            const r = this.adapterCache.get(adapterId);
            if (r) {
                return r;
            }
            else {
                const adapterType = this.pluginManager.getTextSearchAdapterType(conf.type);
                const AdapterClass = await adapterType.getAdapterClass();
                const adapterInstance = new AdapterClass(conf, undefined, this.pluginManager);
                this.adapterCache.set(adapterId, adapterInstance);
                return adapterInstance;
            }
        }));
    }
    relevantAdapters(searchScope) {
        const rootModel = this.pluginManager.rootModel;
        const { aggregateTextSearchAdapters } = rootModel === null || rootModel === void 0 ? void 0 : rootModel.jbrowse;
        const { tracks } = rootModel === null || rootModel === void 0 ? void 0 : rootModel.session;
        const { assemblyName } = searchScope;
        return [
            ...this.getAdaptersWithAssembly(assemblyName, aggregateTextSearchAdapters),
            ...this.getTrackAdaptersWithAssembly(assemblyName, tracks),
        ];
    }
    getAdaptersWithAssembly(assemblyName, confs) {
        return confs.filter(c => { var _a; return (_a = (0, configuration_1.readConfObject)(c, 'assemblyNames')) === null || _a === void 0 ? void 0 : _a.includes(assemblyName); });
    }
    getTrackAdaptersWithAssembly(assemblyName, confs) {
        return confs
            .filter(conf => {
            var _a;
            return (_a = (0, configuration_1.readConfObject)(conf, [
                'textSearching',
                'textSearchAdapter',
                'assemblyNames',
            ])) === null || _a === void 0 ? void 0 : _a.includes(assemblyName);
        })
            .map(conf => conf.textSearching.textSearchAdapter);
    }
    /**
     * Returns list of relevant results given a search query and options
     *
     * @param args - search options/arguments include: search query limit of
     * results to return, searchType...prefix | full | exact", etc.
     */
    async search(args, searchScope, rankFn) {
        const adapters = await this.loadTextSearchAdapters(searchScope);
        const results = await Promise.all(adapters.map(a => a.searchIndex(args)));
        return this.sortResults(results.flat(), rankFn);
    }
    /**
     * Returns array of revelevant and sorted results
     * @param results - array of results from all text search adapters
     * @param rankFn - function that updates results scores
     * based on more relevance
     */
    sortResults(results, rankFn) {
        return rankFn(results.sort((a, b) => -b.getLabel().localeCompare(a.getLabel()))).sort((r1, r2) => r1.getScore() - r2.getScore());
    }
}
exports.default = TextSearchManager;
