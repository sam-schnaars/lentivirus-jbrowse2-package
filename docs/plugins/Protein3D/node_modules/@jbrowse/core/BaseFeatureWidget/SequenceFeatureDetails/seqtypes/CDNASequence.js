"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const mobx_react_1 = require("mobx-react");
const util_1 = require("../util");
const SequenceDisplay_1 = __importDefault(require("./SequenceDisplay"));
const CDNASequence = (0, mobx_react_1.observer)(function ({ utr, cds, exons, sequence, upstream, downstream, feature, includeIntrons, collapseIntron, model, }) {
    var _a;
    const { upperCaseCDS, intronBp, charactersPerRow, showCoordinates, showCoordinatesSetting, } = model;
    const hasCds = cds.length > 0;
    const chunks = (cds.length ? [...cds, ...utr].sort((a, b) => a.start - b.start) : exons).filter(f => f.start !== f.end);
    const toLower = (s) => (upperCaseCDS ? s.toLowerCase() : s);
    const toUpper = (s) => (upperCaseCDS ? s.toUpperCase() : s);
    const strand = feature.strand === -1 ? -1 : 1;
    const fullGenomicCoordinates = showCoordinatesSetting === 'genomic' && includeIntrons && !collapseIntron;
    const mult = fullGenomicCoordinates ? strand : 1;
    let coordStart = fullGenomicCoordinates
        ? strand > 0
            ? feature.start + 1 - ((upstream === null || upstream === void 0 ? void 0 : upstream.length) || 0)
            : feature.end + ((upstream === null || upstream === void 0 ? void 0 : upstream.length) || 0)
        : 0;
    let currStart = 0;
    let currRemainder = 0;
    let upstreamChunk = null;
    if (upstream) {
        const { segments, remainder } = (0, util_1.splitString)({
            str: toLower(upstream),
            charactersPerRow,
            showCoordinates,
        });
        upstreamChunk = (react_1.default.createElement(SequenceDisplay_1.default, { model: model, color: util_1.updownstreamColor, strand: mult, start: currStart, coordStart: coordStart, chunks: segments }));
        currRemainder = remainder;
        currStart = currStart + upstream.length * mult;
        coordStart = coordStart + upstream.length * mult;
    }
    const middleChunks = [];
    for (let idx = 0; idx < chunks.length; idx++) {
        const chunk = chunks[idx];
        const intron = sequence.slice(chunk.end, (_a = chunks[idx + 1]) === null || _a === void 0 ? void 0 : _a.start);
        const s = sequence.slice(chunk.start, chunk.end);
        const { segments, remainder } = (0, util_1.splitString)({
            str: hasCds
                ? chunk.type === 'CDS'
                    ? toUpper(s)
                    : toLower(s)
                : toUpper(s),
            charactersPerRow,
            currRemainder,
            showCoordinates,
        });
        middleChunks.push(react_1.default.createElement(SequenceDisplay_1.default, { key: `${JSON.stringify(chunk)}-mid`, model: model, color: chunk.type === 'CDS' ? util_1.cdsColor : util_1.utrColor, strand: mult, start: currStart, coordStart: coordStart, chunks: segments }));
        currRemainder = remainder;
        currStart = currStart + s.length * mult;
        coordStart = coordStart + s.length * mult;
        if (intron && includeIntrons && idx < chunks.length - 1) {
            const str = toLower(collapseIntron && intron.length > intronBp * 2
                ? `${intron.slice(0, intronBp)}...${intron.slice(-intronBp)}`
                : intron);
            const { segments, remainder } = (0, util_1.splitString)({
                str,
                charactersPerRow,
                currRemainder,
                showCoordinates,
            });
            if (segments.length) {
                middleChunks.push(react_1.default.createElement(SequenceDisplay_1.default, { key: `${JSON.stringify(chunk)}-intron`, model: model, strand: mult, coordStart: coordStart, start: currStart, chunks: segments }));
                currRemainder = remainder;
                currStart = currStart + str.length * mult;
                coordStart = coordStart + str.length * mult;
            }
        }
    }
    let downstreamChunk = null;
    if (downstream) {
        const { segments } = (0, util_1.splitString)({
            str: toLower(downstream),
            charactersPerRow,
            currRemainder,
            showCoordinates,
        });
        downstreamChunk = (react_1.default.createElement(SequenceDisplay_1.default, { start: currStart, model: model, strand: mult, chunks: segments, coordStart: coordStart, color: util_1.updownstreamColor }));
    }
    return (react_1.default.createElement(react_1.default.Fragment, null,
        upstreamChunk,
        middleChunks,
        downstreamChunk));
});
exports.default = CDNASequence;
