"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAbortSignal = checkAbortSignal;
exports.abortBreakPoint = abortBreakPoint;
exports.makeAbortError = makeAbortError;
exports.observeAbortSignal = observeAbortSignal;
exports.isAbortException = isAbortException;
const rxjs_1 = require("rxjs");
class AbortError extends Error {
}
/**
 * properly check if the given AbortSignal is aborted.
 * per the standard, if the signal reads as aborted,
 * this function throws either a DOMException AbortError, or a regular error
 * with a `code` attribute set to `ERR_ABORTED`.
 *
 * for convenience, passing `undefined` is a no-op
 *
 * @param signal -
 * @returns nothing
 */
function checkAbortSignal(signal) {
    if (!signal) {
        return;
    }
    if (!(signal instanceof AbortSignal)) {
        throw new TypeError('must pass an AbortSignal');
    }
    if (signal.aborted) {
        throw makeAbortError();
    }
}
function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
/**
 * Skips to the next tick, then runs `checkAbortSignal`.
 * Await this to inside an otherwise synchronous loop to
 * provide a place to break when an abort signal is received.
 */
async function abortBreakPoint(signal) {
    // it was observed that an actual timeout is needed to get the aborting (wrap
    // hicrenderer in a try catch, console.error the error, and rethrow the error
    // to see). using await Promise.resolve() did not appear to allow aborting to
    // occur
    await timeout(1);
    checkAbortSignal(signal);
}
function makeAbortError() {
    if (typeof DOMException !== 'undefined') {
        return new DOMException('aborted', 'AbortError');
    }
    const e = new AbortError('aborted');
    e.code = 'ERR_ABORTED';
    return e;
}
function observeAbortSignal(signal) {
    if (!signal) {
        return new rxjs_1.Observable();
    }
    return (0, rxjs_1.fromEvent)(signal, 'abort');
}
/**
 * check if the given exception was caused by an operation being intentionally aborted
 * @param exception -
 */
function isAbortException(exception) {
    return (exception instanceof Error &&
        // DOMException
        (exception.name === 'AbortError' ||
            // standard-ish non-DOM abort exception
            exception.code === 'ERR_ABORTED' ||
            // message contains aborted for bubbling through RPC
            // things we have seen that we want to catch here
            // Error: aborted
            // AbortError: aborted
            // AbortError: The user aborted a request.
            !!/\b(aborted|aborterror)\b/i.test(exception.message)));
}
