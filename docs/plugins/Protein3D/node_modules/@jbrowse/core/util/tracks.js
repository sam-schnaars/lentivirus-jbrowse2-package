"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UNSUPPORTED = exports.UNKNOWN = void 0;
exports.getTrackAssemblyNames = getTrackAssemblyNames;
exports.getConfAssemblyNames = getConfAssemblyNames;
exports.getRpcSessionId = getRpcSessionId;
exports.getParentRenderProps = getParentRenderProps;
exports.getBlob = getBlob;
exports.getBlobMap = getBlobMap;
exports.setBlobMap = setBlobMap;
exports.storeBlobLocation = storeBlobLocation;
exports.makeIndex = makeIndex;
exports.makeIndexType = makeIndexType;
exports.getFileName = getFileName;
exports.guessAdapter = guessAdapter;
exports.guessTrackType = guessTrackType;
exports.generateUnsupportedTrackConf = generateUnsupportedTrackConf;
exports.generateUnknownTrackConf = generateUnknownTrackConf;
exports.getTrackName = getTrackName;
const mobx_state_tree_1 = require("mobx-state-tree");
const index_1 = require("./index");
const configuration_1 = require("../configuration");
/* utility functions for use by track models and so forth */
function getTrackAssemblyNames(track) {
    return getConfAssemblyNames(track.configuration);
}
function getConfAssemblyNames(conf) {
    const trackAssemblyNames = (0, configuration_1.readConfObject)(conf, 'assemblyNames');
    if (!trackAssemblyNames) {
        // Check if it's an assembly sequence track
        const parent = (0, mobx_state_tree_1.getParent)(conf);
        if ('sequence' in parent) {
            return [(0, configuration_1.readConfObject)(parent, 'name')];
        }
        else {
            throw new Error('unknown assembly names');
        }
    }
    return trackAssemblyNames;
}
/**
 * return the rpcSessionId of the highest parent node in the tree that has an
 * rpcSessionId */
function getRpcSessionId(thisNode) {
    let highestRpcSessionId;
    for (let node = thisNode; !(0, mobx_state_tree_1.isRoot)(node); node = (0, mobx_state_tree_1.getParent)(node)) {
        if ('rpcSessionId' in node) {
            highestRpcSessionId = node.rpcSessionId;
        }
    }
    if (!highestRpcSessionId) {
        throw new Error('getRpcSessionId failed, no parent node in the state tree has an `rpcSessionId` attribute');
    }
    return highestRpcSessionId;
}
/**
 * given an MST node, get the renderprops of the first parent container that
 * has renderProps
 * @param node -
 * @returns renderprops, or empty object if none found
 */
function getParentRenderProps(node) {
    for (let currentNode = (0, mobx_state_tree_1.getParent)(node); !(0, mobx_state_tree_1.isRoot)(currentNode); currentNode = (0, mobx_state_tree_1.getParent)(currentNode)) {
        if ('renderProps' in currentNode) {
            return currentNode.renderProps();
        }
    }
    return {};
}
exports.UNKNOWN = 'UNKNOWN';
exports.UNSUPPORTED = 'UNSUPPORTED';
let blobMap = {};
// get a specific blob
function getBlob(id) {
    return blobMap[id];
}
// used to export entire context to webworker
function getBlobMap() {
    return blobMap;
}
// used in new contexts like webworkers
function setBlobMap(map) {
    blobMap = map;
}
let counter = 0;
// blob files are stored in a global map. the blobId is based on a combination
// of timestamp plus counter to be unique across sessions and fast repeated
// calls
function storeBlobLocation(location) {
    if ('blob' in location) {
        const blobId = `b${+Date.now()}-${counter++}`;
        blobMap[blobId] = location.blob;
        return { name: location.blob.name, blobId, locationType: 'BlobLocation' };
    }
    return location;
}
/**
 * creates a new location from the provided location including the appropriate suffix and location type
 * @param location - the FileLocation
 * @param suffix - the file suffix (e.g. .bam)
 * @returns the constructed location object from the provided parameters
 */
function makeIndex(location, suffix) {
    if ('uri' in location) {
        return { uri: location.uri + suffix, locationType: 'UriLocation' };
    }
    if ('localPath' in location) {
        return {
            localPath: location.localPath + suffix,
            locationType: 'LocalPathLocation',
        };
    }
    return location;
}
/**
 * constructs a potential index file (with suffix) from the provided file name
 * @param name - the name of the index file
 * @param typeA - one option of a potential two file suffix (e.g. CSI, BAI)
 * @param typeB - the second option of a potential two file suffix (e.g. CSI, BAI)
 * @returns a likely name of the index file for a given filename
 */
function makeIndexType(name, typeA, typeB) {
    return (name === null || name === void 0 ? void 0 : name.toUpperCase().endsWith(typeA)) ? typeA : typeB;
}
function getFileName(track) {
    const uri = 'uri' in track ? track.uri : undefined;
    const localPath = 'localPath' in track ? track.localPath : undefined;
    const blob = 'blobId' in track ? track : undefined;
    return ((blob === null || blob === void 0 ? void 0 : blob.name) ||
        (uri === null || uri === void 0 ? void 0 : uri.slice(uri.lastIndexOf('/') + 1)) ||
        (localPath === null || localPath === void 0 ? void 0 : localPath.slice(localPath.replace(/\\/g, '/').lastIndexOf('/') + 1)) ||
        '');
}
function guessAdapter(file, index, adapterHint, model) {
    if (model) {
        const { pluginManager } = (0, index_1.getEnv)(model);
        const adapterGuesser = pluginManager.evaluateExtensionPoint('Core-guessAdapterForLocation', (_file, _index, _adapterHint) => {
            return undefined;
        });
        const adapter = adapterGuesser(file, index, adapterHint);
        if (adapter) {
            return adapter;
        }
    }
    return {
        type: exports.UNKNOWN,
    };
}
function guessTrackType(adapterType, model) {
    if (model) {
        const session = (0, index_1.getSession)(model);
        const trackTypeGuesser = (0, index_1.getEnv)(session).pluginManager.evaluateExtensionPoint('Core-guessTrackTypeForLocation', (_adapterName) => {
            return undefined;
        });
        const trackType = trackTypeGuesser(adapterType);
        if (trackType) {
            return trackType;
        }
    }
    return 'FeatureTrack';
}
function generateUnsupportedTrackConf(trackName, trackUrl, categories) {
    const conf = {
        type: 'FeatureTrack',
        name: `${trackName} (Unsupported)`,
        description: `Support not yet implemented for "${trackUrl}"`,
        category: categories,
        trackId: '',
    };
    conf.trackId = (0, index_1.objectHash)(conf);
    return conf;
}
function generateUnknownTrackConf(trackName, trackUrl, categories) {
    const conf = {
        type: 'FeatureTrack',
        name: `${trackName} (Unknown)`,
        description: `Could not determine track type for "${trackUrl}"`,
        category: categories,
        trackId: '',
    };
    conf.trackId = (0, index_1.objectHash)(conf);
    return conf;
}
function getTrackName(conf, session) {
    const trackName = (0, configuration_1.readConfObject)(conf, 'name');
    if (!trackName && (0, configuration_1.readConfObject)(conf, 'type') === 'ReferenceSequenceTrack') {
        const asm = session.assemblies.find(a => a.sequence === conf);
        return asm
            ? `Reference sequence (${(0, configuration_1.readConfObject)(asm, 'displayName') || (0, configuration_1.readConfObject)(asm, 'name')})`
            : 'Reference sequence';
    }
    return trackName;
}
