"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileLocation = exports.UriLocation = exports.UriLocationRaw = exports.BlobLocation = exports.LocalPathLocation = exports.Region = exports.NoAssemblyRegion = exports.ElementId = void 0;
const mobx_state_tree_1 = require("mobx-state-tree");
const nanoid_1 = require("../nanoid");
exports.ElementId = mobx_state_tree_1.types.optional(mobx_state_tree_1.types.identifier, () => (0, nanoid_1.nanoid)());
exports.NoAssemblyRegion = mobx_state_tree_1.types
    .model('NoAssemblyRegion', {
    refName: mobx_state_tree_1.types.string,
    start: mobx_state_tree_1.types.number,
    end: mobx_state_tree_1.types.number,
    reversed: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
})
    .actions(self => ({
    setRefName(newRefName) {
        self.refName = newRefName;
    },
}));
exports.Region = mobx_state_tree_1.types.compose('Region', exports.NoAssemblyRegion, mobx_state_tree_1.types.model({
    assemblyName: mobx_state_tree_1.types.string,
}));
exports.LocalPathLocation = mobx_state_tree_1.types.model('LocalPathLocation', {
    locationType: mobx_state_tree_1.types.literal('LocalPathLocation'),
    localPath: mobx_state_tree_1.types.string,
});
// like how blobId is used to get a blob map
exports.BlobLocation = mobx_state_tree_1.types.model('BlobLocation', {
    locationType: mobx_state_tree_1.types.literal('BlobLocation'),
    name: mobx_state_tree_1.types.string,
    blobId: mobx_state_tree_1.types.string,
});
exports.UriLocationRaw = mobx_state_tree_1.types.model('UriLocation', {
    locationType: mobx_state_tree_1.types.literal('UriLocation'),
    uri: mobx_state_tree_1.types.string,
    baseUri: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
    internetAccountId: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
    // auths information (such as tokens) needed for using this resource.
    // if provided, these must be completely sufficient for using it
    internetAccountPreAuthorization: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.model('InternetAccountPreAuthorization', {
        internetAccountType: mobx_state_tree_1.types.string,
        authInfo: mobx_state_tree_1.types.frozen(),
    })),
});
exports.UriLocation = mobx_state_tree_1.types.snapshotProcessor(exports.UriLocationRaw, {
    postProcessor: snap => {
        // xref https://github.com/mobxjs/mobx-state-tree/issues/1524 for Omit
        const { baseUri, ...rest } = snap;
        if (!baseUri) {
            return rest;
        }
        return snap;
    },
});
exports.FileLocation = mobx_state_tree_1.types.snapshotProcessor(mobx_state_tree_1.types.union(exports.LocalPathLocation, exports.UriLocation, exports.BlobLocation), {
    // @ts-expect-error
    preProcessor(snap) {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!snap) {
            return undefined;
        }
        // @ts-expect-error
        // xref https://github.com/mobxjs/mobx-state-tree/issues/1524 for Omit
        const { locationType, ...rest } = snap;
        if (!locationType) {
            // @ts-expect-error
            const { uri, localPath, blob } = rest;
            let locationType = '';
            if (uri !== undefined) {
                locationType = 'UriLocation';
            }
            else if (localPath !== undefined) {
                locationType = 'LocalPathLocation';
            }
            else if (blob !== undefined) {
                locationType = 'BlobLocation';
            }
            return { ...rest, locationType };
        }
        return snap;
    },
});
