"use strict";
/* eslint-disable react-refresh/only-export-components */
// This file is a ponyfill for the HTML5 OffscreenCanvas API.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageBitmapType = exports.createImageBitmap = exports.createCanvas = void 0;
exports.drawImageOntoCanvasContext = drawImageOntoCanvasContext;
const detect_node_1 = __importDefault(require("detect-node"));
const canvas_sequencer_1 = require("canvas-sequencer");
function drawImageOntoCanvasContext(imageData, context) {
    if (imageData.serializedCommands) {
        const seq = new canvas_sequencer_1.CanvasSequence(imageData.serializedCommands);
        seq.execute(context);
    }
    else {
        context.drawImage(imageData, 0, 0);
    }
}
const weHave = {
    realOffscreenCanvas: typeof OffscreenCanvas === 'function',
    node: detect_node_1.default,
};
if (weHave.realOffscreenCanvas) {
    exports.createCanvas = (width, height) => new OffscreenCanvas(width, height);
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    exports.createImageBitmap = window.createImageBitmap || self.createImageBitmap;
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    exports.ImageBitmapType = window.ImageBitmap || self.ImageBitmap;
}
else if (weHave.node) {
    // use node-canvas if we are running in node (i.e. automated tests)
    exports.createCanvas = (...args) => {
        // @ts-expect-error
        return nodeCreateCanvas(...args);
    };
    exports.createImageBitmap = async (canvas) => {
        const dataUri = canvas.toDataURL();
        // @ts-expect-error
        const img = new nodeImage();
        return new Promise((resolve, reject) => {
            // need onload for jest
            img.onload = () => {
                resolve(img);
            };
            img.onerror = reject;
            img.src = dataUri;
        });
    };
}
else {
    exports.createCanvas = (width, height) => {
        const context = new canvas_sequencer_1.CanvasSequence();
        return {
            width,
            height,
            getContext() {
                return context;
            },
        };
    };
    exports.createImageBitmap = async (canvas) => {
        const ctx = canvas.getContext('2d');
        return {
            height: canvas.height,
            width: canvas.width,
            serializedCommands: ctx.toJSON(),
            containsNoTransferables: true,
        };
    };
    exports.ImageBitmapType = String;
}
